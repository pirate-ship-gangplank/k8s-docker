젠킨스를 통한 CI/CD 아이템은 대표적으로 Freestyle과 Pipeline으로 나눌 수 있다.

## Freestyle

실행 순서

1. 깃헙에서 빌드할 정보가 담긴 파일들을 pull 
2. 받은 파일들을 이용해서 컨테이너 이미지 빌드
3. 빌드한 이미지를 레지스트리에 push
4. 레지스트리에 저장한 이미지를 쿠버네티스 클러스터에 디플로이먼트로 생성하고 로드밸런서 서비스로 노출
- 2~4단계의 작업들은 젠킨스 빌드시 실행할 shell script 코드를 command로 입력한다.
- 젠킨스 웹 화면에서 메뉴를 눌러 필요한 것을 정의하는 방식이기 때문에 간단한 단일 작업인 경우에 유용하다.
- 하지만, 젠킨스의 웹 화면에 직접 shell script를 입력하기 때문에 빌드 작업의 명령어에 변경이 있을 경우 작업 관리 및 변경 사항의 추적이 어렵다.

## Pipeline

젠킨스의 Pipeline은 연속적인 작업을 코드 또는 파일로 정의해주는 젠킨스 기능이다.

- 파이프라인은 고유의 문법으로 작성된 코드 또는 이러한 내용을 담고 있는 파일로 이루어져있다.
- 파이프라인을 통해 CI/CD 내용을 코드 또는 파일로 정의해 단순히 코드나 파일을 가져다 쓰기만 하면 된다.
- 파이프라인 2가지 문법 : 스크립트 문법은 젠킨스의 고유 문법을 사용하는데, 익숙하지 않아 어려움이 있고, 선언적 문법은 익숙한 yaml 문법을 그대로 사용할 수 있기 때문에 선언적 문법으로 작성하는 것이 좋다.

 파이프라인 실행 순서

1. 깃헙과 같은 소스코드 저장소에서 빌드할 소스 코드와 젠킨스 내부의 작업을 선언적인 문법으로 정의해 둔 Jenkinsfile을 내려받는다.
2. 내려받은 Jenkinsfile을 해석해서 작성자의 의도에 맞는 작업을 자동으로 수행한다. (작업 내용은 이전에 Freestyle로 작성한 것과 다르지 않지만, 이를 간편하게 사용하기 위해 파일로 만들어 둔 것이다.)

### Jenkinsfile

- pipeline : 선언적인 문법이 시작하는 부분. 선언적인 문법으로 작성된 작업들은 `pipeline { }` 사이에 작업 내용을 작성해야 한다.
- agent : 작업을 수행할 에이전트를 지정하고 필요한 설정을 한다. 지정된 에이전트 내부에서 젠킨스 빌드 작업이 실제로 수행되는데, 다음과 같은 방식으로 지정할 수 있다.
    - any : 사용 가능한 에이전트를 젠킨스가 임의로 지정한다.
    - label : 특정 레이블과 일치하는 에이전트 노드를 지정한다.
    - docker : 에이전트 노드의 이미지를 도커로 지정한다.
    - kubernetes : 에이전트 노드를 쿠버네티스 파드로 지정한다.
    - 기타 : 플러그인에 따라 지정할 수 있는 에이전트가 매우 많다.
- stages : stage들을 모아서 정의하고 이를 순서대로 진행하게 해준다.
- stage : step들을 정의하는 영역. stage는 괄호 안에 여러개의 step들을 정의할 수 있는데, 이 step들 내부에서 실제로 동작하는 내용들이 정의된다.
- steps : stage 내부에서 실제 작업 내용을 작성하는 영역. stage 내부에 여러 step이 존재할 수 있다. step 영역 내부에서 script, sh, git과 같은 작업을 통해서 실제 동작을 정의한다.

```yaml
pipeline {
  agent any  # 사용 가능한 agent를 젠킨스가 임의로 찾는다.
  stages {
    stage('git scm update') {
      steps {
        git url: 'https://github.com/parkdoowon/repo-name', branch: 'master'
      }
    }
    stage('docker build and push') {
      steps {
        sh '''
        docker build -t 192.169.1.10:8443/echo-ip
        docker push 192.168.1.10:8443/echo-ip
      }
    }

    # other stage..

  }
}
```

- agent가 any인 이유는 stage 별로 작업을 수행할 에이전트가 제각각이기 때문이고, 그렇다면 각 stage 별로 젠킨스가 적절한 에이전트를 매핑해주려나?

## 무중단 배포

언제나 삭제하고 다시 생성하는 파드의 특성상 중요한 서비스의 중단이 없도록 하는 일이 중요하다.

### 롤링 업데이트

파드를 레플리카셋 단위로 나누어 모든 레플리카셋에 속해 있는 파드가 업데이트 된 후에 레플리카셋을 삭제한다.

### 블루그린

모든 파드가 업데이트된 이후에 트래픽을 전달한다.

2개의 디플로이먼트를 생성하고 기존 디플로이먼트(블루)로 계속 트래픽을 전달하다가, 새로 배포되는 디플로이먼트(그린)에 모든 파드가 업데이트 되면 모든 서비스를 새로 배포된 디플로이먼트(그린)으로 보낸다. 그리고 기존의 디플로이먼트(블루)는 삭제한다.

(쿠버네티스 환경에서 블루그린 배포는 기본 기능이 아니어서 구성할 수 없지만, 젠킨스를 이용하면 가능하다.)

- 장점 :
    - 디플로이먼트에서 제공하는 서비스를 넘기면 서비스의 중단없이 연속적으로 배포가 가능하다.
    - 문제가 발생한 경우, 기존에 서비스하던 디플로이먼트(블루)로 원복하는 것도 수월해 장애 복구도 쉽다.
- 단점 :
    - 배포를 위한 디플로이먼트를 만들어야해서 기존 디플로이먼트 배포 대비 최소 2배 이상의 리소스가 든다.
    - 하지만, 장애 복구의 수월함과 무중단 배포라는 점을 생각하면 크게 부각되는 단점은 아닐 수 있다.

# 젠킨스 플러그인

젠킨스는 다양한 플러그인을 제공하는데, 이러한 플러그인들을 조합하면 단일 플러그인으로 만들지 못하는 기능을 만들 수 있다. 

(**쿠버네티스용 지속적 배포, 슬랙 알림, 변경 내용 비교** → 이렇게 3개의 플러그인을 조합하여 GitOps를 만들 수 있다.)

## GitOps 만들기

GitOps : Git과 Operations의 합성어로, git을 통해 모든 것을 선언적으로 SCM(SourceCode Manager)에 업데이트하면 오퍼레이터(젠키스와 같은 것)가 변경분을 감지해 대상 시스템에 배포한다.

→ 변경 내용을 깃헙 저장소에 선언해두면 이를 젠킨스가 읽어서 운영 시스템에 적용한다.

[ 장점 ]

- 깃헙 저장소의 내용과 실제 상용 및 운영 환경의 내용을 동일하게 가져갈 수 있다.
- 배포를 표준화해 자동으로 배포되도록 할 수 있다.
- 미리 정의된 설정으로, 수동으로 진행했을 때의 사람의 실수로 줄일 수 있다.