## 5장 : 지속적 통합과 배포 자동화, 젠킨스

컨테이너 인프라 환경에서 쿠버네티스를 사용하는 이유는 컨테이너 애플리케이션을 유연하고 빠르게 배포하고 운영하기 위해서입니다

4장에서 진행한 과정을 정리해보겠습니다

1. 깃허브 등의 저장소에 저장해 둔 애플리케이션 소스 코드를 내려받아 도커 컨테이너 이미지로 빌드합니다

2. 빌드한 컨테이너 이미지를 쿠버네티스에서 사용할 수 있도록 레지스트리에 등록합니다

3. 레지스트리에 등록된 이미지를 기반으로 쿠버네티스 오브젝트를 생성합니다

4. 생성한 오브젝트(파드/디플로이먼트)를 외부에서 접속할 수 있도록 서비스 형태로 노출합니다

```json
새로 개발한 애플리케이션을 쿠버네티스에서 사용하는 과정

1) docker build > docker push > kubectl create > kubectl expose
```

## 5.1 : 컨테이너 인프라 환경에서 CI/CD

CI : 코드를 커밋하고 빌드햇을 때 정상적으로 작동하는지 반복적으로 검증해 애플리케이션의 신뢰성을 높이는 작업

> CI 과정을 마친 애플리케이션은 신뢰할 수 있는 상태가 됩니다

CD : CI 과정에서 생성된 신뢰할 수 있는 애플리케이션을 실제 상용 환경에 자동으로 배포하는 것

CD에 미리 정의하면 실수를 줄이고, 실제 적용 시간도 최소화할 수 있습니다

```json
개발자 소스 커밋 - CI 단계 - 애플리케이션 자동 빌드, 테스트를 거쳐 배포할 수 있는 애플리케이션인지 확인

테스트 통과 - CD 단계 - 애플리케이션을 컨테이너 이미지로 만들어서 파드, 디플로이먼트, 스테이트풀셋 등 다양한 오브젝트 조건에 맞춰 미리 설정한 파일을 통해 배포
```

### 5.1.1 : CI/CD 도구 비교

|구분|팀시티|깃허브 액션|뱀부|젠킨스|
|---|---|---|---|---|
|설치 방식|직접 설치|깃허브 연동|직접 설치|직접 설치|
|연계 기능|보통|보통|부족|매우 많음|
|가격|무료/유료|무료/유료|유료|무료|
|기능 추가|보통|매우 다양함|보통|매우 다양함|
|범용성|보통|매우 큼|보통|매우 큼|
|정보량|부족함|많음|많음|매우 많음|

### 5.1.2 : 젠킨스로 쿠버네티스 운영 환경 개선하기

개발자가 작성한 애플리케이션 코드를 소스 코드 저장소에 푸시하면,

쿠버네티스 내부에 설치된 젠킨스는 애플리케이션 코드를 빌드하고 레지스트리에 푸시한 후에 쿠버네티스에서 사용 가능한 형태로 배포합니다

컨테이너 인프라 환경에서 젠킨스를 사용하는 주된 이유는 애플리케이션을 컨테이너로 만들고 배포하는 과정을 자동화하기 위해서입니다

젠킨스는 컨트롤러와 에이전트 형태로 구성한 다음 배포해야 하며 여기에 필요한 설정을 모두 넣어야 합니다

애플리케이션을 배포하기 위한 환경을 하나하나 구성하는 것은 매우 복잡하고 번거로운 일이며,

고정된 값이 아니기 때문에 매니페스트로 작성해 그대로 사용할 수가 없습니다

구성 환경에 따라 많은 부분을 동적으로 변경해야 합니다

## 5.2 : 젠킨스 설치를 위한 간편화 도구 살펴보기

### 5.2.1 : 배포 간편화 도구 비교하기

|구분|큐브시티엘|커스터마이즈|헬름|
|---|---|---|---|
|설치 방법|쿠버네티스에 기본 포함|별도 실행 파일 또는 쿠버네티스에 통합|별도 설치|
|배포 대상|정적인 야믈 파일|커스터마이즈 파일|패키지(차트)|
|주 용도|오브젝트 관리 및 배포|오브젝트의 가변적 배포|패키지 단위 오브젝트 배포 및 관리|
|가변적 환경|대응 힘듦(야믈 수정 필요)|간단한 대응 가능|복잡한 대응 가능|
|기능 복잡도|단순함|보통|복잡함|

### 5.2.2 : 커스터마이즈로 배포 간편화하기

커스터마이즈는 야믈 파일에 정의된 값을 사용자가 원하는 값으로 변경할 수 있습니다

쿠버네시트에서 오브젝트에 대한 수정 사항을 반영하려면 사용자가 직접 야믈 파일을 편집기 프로그램으로 수정해야 합니다

만약 수정해야 하는 야믈 파일이 매우 많거나 하나의 야믈 파일로 환경이 다른 여러 개의 쿠버네티스 클러스터에 배포해야 해서

LABEL 이나 NAME 같은 일부 항목을 수정해야 한다면 매번 일일이 고치는 데 많은 노력이 듭니다

커스터마이즈는 이를 위해 kustomize 명령을 제공합니다

kustomize 명령과 create 옵션으로 kustomization.yaml 이라는 기본 매니페스트를 만들고, 이 파일에 변경해야 하는 값들을 적용합니다

### 5.2.3 : 헬름으로 배포 간편화하기

헬름을 통한 배포는 커스터마이즈에서 제한적이었던 주소 할당 영역과 같은 값을 대체하면서 단단하게 설치할 수 있도록 설계돼 있습니다

쿠버네티스에 패키지를 손쉽게 배포할 수 있도록 패키지를 관리하는 쿠버네티스 전용 패키지 매니저입니다

실행 파일뿐만 아니라 실행 환경에 필요한 의존성 파일과 환경 정보들의 묶음입니다

그리고 패키지 매니저는 외부에 있는 저장소에서 패키지 정보를 받아와 패키지를 안정적으로 관리하는 도구입니다

패키지 매니저는 다양한 목적으로 사용되지만, 가장 중요한 목적은 설치에 필요한 의존성 파일들을 관리하고 간편하게 설치할 수 있도록 도와주는 것입니다

- 플랫폼별 패키지 매니저

|플랫폼|패키지 매니저|저장소|사용 목적|
|---|---|---|---|
|리눅스|yum, apt|배포판 저장소|소프트웨어 의존성 관리|
|파이썬|pip|pypi.org|파이썬 모듈 의존성 관리|
|자바|maven|mvnrepository.com|자바 라이브러리 의존성 관리|
|쿠버네티스|helm|artifacthub.io|쿠버네티스 패키지 관리|

- 패키지 매니저의 기능
  - 패키지 검색 : 설정한 저장소에서 패키지를 검색하는 기능을 제공합니다
  - 패키지 관리 : 저장소에서 패키지 정보를 확인하고, 사용자 시스템에 패키지 설치, 삭제, 업그레이드, 되돌리기 등을 할 수 있습니다
  - 패키지 의존성 관리 : 패키지를 설치할 때 의존하는 소프트웨어를 같이 설치하고, 삭제할 때 같이 삭제할 수 있습니다
  - 패키지 보안 관리 : 디지털 인증서와 패키지에 고유하게 발행되는 체크섬이라는 값으로 해당 패키지의 소프트웨어나 의존성이 변조됐는지 검사할 수 있습니다
    
#### 생산자 영역

생산자가 헬름 명령으로 작업 공간을 생성하면 

templates 디렉터리로 애플리케이션 배포에 필요한 여러 야믈 파일과 구성 파일을 작성할 수 있습니다

이때 templates 디렉터리에서 조건별 분기, 값 전달 등을 처리할 수 있도록 values.yaml에 설정된 키를 사용합니다

필요한 패키지의 여러 분기 처리나 배포에 대한 구성이 완료되면 생산자는 차트의 이름, 목적, 배포되는 애플리케이션 버전과 같은 패키지 정보를 Charts.yaml 에 채워 넣습니다

#### 아티팩트허브 영역

아티팩트허브 검색을 통해 사용자가 찾고자 하는 애플리케이션 패키지를 검색하면 해당 패키지가 저장된 주소를 확인합니다

각 애플리에키션을 개발하는 주체가 관리합니다

#### 사용자 영역

사용자는 설치하려는 애플리케이션의 차트 저장소 주소를 아티팩트허브에서 얻으면 헬름을 통해서 주소를 등록합니다

이를 최신으로 업데이트한 이후에 차트를 내려받고 설치합니다

## 5.3 : 젠킨스 설치 및 설정하기

### 5.3.1 : 헬름으로 젠킨스 설치하기

#### 테인트(taints)와 톨러레이션(tolerations)

일반적으로 테인트와 톨러레이션은 혼합해서 사용하는데, 개념적으로 매우 혼동이 올 수 있습니다

**테인트**는 손에 잡기 싫은 것, 피하고 싶은 것, 가지 말았으면 하는 것

테인트가 설정되면 그곳은 설거지가 끝난 이후에 수채구멍과 같습니다

하지만, 상황에 따라 테인트가 설정돼 있는 곳을 꼭 만져야 할 때가 있는데, 이런 경우는 인내하고 처리해야 합니다

그러기 위해서는 **톨러레이션**. 즉, 참아내는 인내가 필요한 것입니다

쿠버네티스의 테인트와 톨러레이션은 사전적인 의미와 반대입니다

매우 특별하게 취급돼야 하는 곳에는 테인트를 설정해, 쉽게 접근하지 못하는 소중한 것으로 설정합니다

그리고, 톨러레이션이라는 특별한 키를 가져야만 이곳에 출입할 수 있습니다

```yaml
taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master

tolerations:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
```

테인트는 키와 값 그리고 키와 값에 따른 효과의 조합을 통해 테인트를 설정한 노드에 파드 배치의 기준을 설정합니다

톨러레이션은 테인트와 마찬가지로 키, 값, 효과를 가지고 있으며 이외에 연산자를 추가로 가지고 있습니다

|효과|테인트가 설정된 노드에 파드 신규 배치|파드가 배치된 노드에 테인트 설정|
|---|---|---|
|NoSchedule|노드에 파드 배치를 거부|노드에 존재하는 파드 유지|
|PreferNoSchedule|다른 노드에 파드 배치가 불가능할 때는 노드에 파드 배치|노드에 존재하는 파드 유지|
|NoExecute|노드에 파드 배치를 거부|파드를 노드에서 제거|

톨러레이션은 테인트가 설정된 노드로 들어가기 위한 특별한 열쇠의 역할을 하며 키와 효과는 반드시 일치해야 합니다

operator 에는 Equal과 Exists가 있습니다

Equal : taint와 toleration의 키와 값 그리고 효과까지 일치하는 경우
Exists : 키와 효과의 일치 여부를 판단하고, 값은 반드시 생략해야 합니다 

(키와 효과를 모두 생략한 상태에서 Exists 연산자만 사용한다면 테인트의 키와 효과는 모든 키와 모든 효과를 의미하므로 Exists 연산자 하나만으로도 테인트가 설정된 모든 노드에 대해 해당 톨러레이션을 설정한 파드를 배포할 수 있게 됩니다)

### 5.3.2 젠킨스 살펴보기

젠킨스 컨트롤러가 단독으로 설치할 경우에는 컨트롤러가 설치된 서버에서 

젠킨스 자체 시스템 관리, CI/CD 설정, 빌드 등의 작업을 모두 젠킨스 컨트롤러 단일 녿에서 수행합니다

컨트롤러-에이전트 구조로 설치할 경우 컨트롤러는 젠킨스 자체의 관리 및 CI/CD와 관련된 설정만을 담당하고 실제 빌드 작업은 에이전트로 설정된 노드에서 이루어집니다

### 5.3.4 : 젠킨스 에이전트 설정하기

쿠버네티스의 역할 부여 구조는 **할 수 있는 일**(무엇을 할 수 있나?)과 **할 수 있는 주체**(누가 할 수 있나?)의 결합으로 이루어집니다

- Rules

역할 기반 접근 제어에서 '할 수 있는 일'과 관련된 Role, ClusterRole이 가지고 있는 자세한 행동 규칙입니다

특정 API를 통해서 어떠한 자원에 접근해 목록이나 정보를 조회하거나 자원을 생성, 삭제, 수정하는 등의 행위를 하는 것을 의미합니다

- Role, ClusterRole

'할 수 있는 일'을 대표하는 오브젝트입니다

Rules에 적용된 규칙에 따른 동작을 할 수 있으며 적용 범위에 따라 Role과 ClusterRole로 나뉩니다

Role은 해당 Role을 가진 주체가 특정 namespace 에 대해서 접근할 수 있습니다

ClusterRole은 해당 ClusterRole을 가진 주체가 쿠버네티스 클러스터 전체에 대해서 접근할 수 있도록 합니다

- RoleBinding, ClusterRoleBinding

'무엇을 할 수 있나?' 라는 속성을 '할 수 있는 주체' 속성의 Subjects와 연결시켜주는 역할을 합니다

RoleBinding은 앞에서 설명한 Role과 결합하여 네임스페이스 범위의 접근 제어를 수행합니다

ClusterRoleBinding은 ClusterRole과 결합해 클러스터 전체 범위의 접근 제어를 수행합니다

- Subjects

행위를 수행하는 주체를 의미합니다

Subjects는 특정 사용자 혹은 그룹, 서비스 어카운트를 속성으로 가질 수 있습니다

쿠버네티스 클러스터에 등록된 사용자의 목록은 kubeconfig의 users 섹션에 기록돼 있습니다

파드는 네임스페이스에 존재하는 default 서비스 어카운트를 사용하거나 특정한 서비스 어카운트를 사용하도록 설정할 수 있으며

파드 내부의 프로세스는 설정된 서비스 어카운트로서 쿠버네티스상에 존재하는 자원에 접근을 시도할 수 있습니다