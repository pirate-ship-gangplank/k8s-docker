# 파드, 컨테이너, 도커, 쿠버네티스

- 컨테이너들이 모여서 파드를 이룬다.
- 파드들은 워커 노드라는 노드 단위로 관리한다.
- 워커 노드 + 마스터 노드 = 쿠버네티스 클러스터

- 파드는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공한다.
- 컨터이너들이 정상 작동하는지 확인하고, 네트워크나 저장 공간을 서로 공유하게 한다.
→ 파드의 이런 점 때문에 컨테이너들은 마치 하나의 호스트에 존재하는 것처럼 동작한다.

## 컨테이너

하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간

- 개별적인 실행 환경 : CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경
- 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리돼 관리돼서, 각 컨테이너 안에서 실행되는 애플리케이션들은 서로 독립적으로 작동할 수 있다.
- 이전부터 리눅스나 유닉스는 하나의 호스트 OS 안에서 자원을 분리해 할당했지만, 파일 시스템 설정이나 자원 및 공간 관리 과정이 복잡하였다. 
→ 도커의 등장으로 이 과정이 쉬워진 것이다.

## 이미지

이미지는 실행 파일, 컨테이너는 실행된 파일의 느낌

[이미지 구조]

- 태그 : 이미지에 태그 이름을 지정할 수 있다. 이미지를 pull 할때 아무런 조건을 주지 않으면 latest 태그가 적용된다.
- 레이어 : 하나의 이미지는 여러 개의 레이어로 이루어져 있어서 레이어마다 Pull complete 메세지가 발생한다.
- 다이제스트 : 이미지의 고유 식별자. 해시 함수로 생성되며 이미지가 동일한지 검증하는데 사용한다. 
→ 이름이나 태그가 다르더라도 다이제스트가 같으면 같은 이미지이다.
- 상태 : 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있다.
→ 형식은 `레지스트리 이름`/ `이미지 이름` : `태그` 이다.

### 이미지 태그

태그 : 이름이 동일한 이미지에 추가하는 식별자

- 이미지의 이름이 동일해도 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하기 위해 사용한다.
- 이미지 이름만 쓰고 태그를 명시하지 않으면 latest 태그를 기본으로 사용한다.

### 이미지 레이어 구조

이미지는 레이어를 공유하기 때문에 이미지에 동일한 레이어가 포함되어 있으면 해당 레이어 용량 만큼을 아낄 수 있다.

### 컨테이너 실행

`docker run [옵션] 이미지명:태그|@다이제스트`

- -d : 컨테이너를 백그라운드에서 구동하는 옵션. 옵션을 생략하면 컨테이너 내부에서 실행되는 애프리케이션의 상태가 화면에 계속 표시가 된다. 
→ 계속 작동해야하는 서버나 DB 같은 프로그램은 -d 옵션을 붙여 백그라운드로 동작하게 하는 것이 좋다.
- --restart always : 컨테이너의 재시작과 관련된 옵션. 예상치못한 오류가 발생하거나 도커가 중지되는 경우에 중지된 컨테이너를 자동으로 시작할 수 있도록 하는 옵션이다.

[ 컨테이너 상태들 확인 ]

`docker ps`

- CONTATINER ID : 컨테이너를 식별하기 위한 고유 id
- IMAGE : 컨테이너를 만드는 데 사용한 이미지
- COMMAND : 컨테이너가 생성될 때 내부에서 직동할 프로그램을 실행하는 명령어
- CREATED : 컨테이너가 생성된 시각
- STATUS : 컨테이너가 작동을 시작한 시각
- PORTS : 컨테이너가 사용하는 포트와 프로토콜을 표시. 80/tcp는 컨테이너 내부에서 80번 포트와 TCP 프로토콜을 사용한다는 의미이다.
- NAMES : 컨테이너 이름. 따로 지정하지 않으면 랜덤하게 이름 부여된다.

[ 80번 포트 접속 불가 문제 ]

`curl 127.0.0.1` 로 요청을 했을 때 동작하지 않는다.

- localhost로 마스터 노드로 접속은 되나, 마스터 노드에서 컨테이너로 연결해주는 부분이 없다.

`docker run -d -p 8080:80 --restart always nginx` 명령 실행

- -p 옵션 : docker run 명령에 붙이는 옵션으로, 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션.
→ `docker run -p <요청받을 호스트 포트> : <연결할 컨테이너 포트>` 로 옵션을 설정할 수 있다.

docker ps 으로 컨테이너 상태를 조회해보면,

- PORTS 부분이 0.0.0.0:8080→80/tcp로 변경되었다.
    - `0.0.0.0` (모든 주소) : 존재하는 모든 네트워크 어댑터.
    - `0.0.0.0:8080` : 모든 주소의 8080 포트로 들어오는 요청
    - `0.0.0.0:8080->80/tcp` : 모든 주소(0.0.0.0)의 8080 포트로 들어오는 요청을 컨테이너 내부의 80번 포트로 보낸다는 의미이다.

# 컨테이너 내부 파일 변경

### 컨테이너 내부에서 컨테이너 외부 파일을 사용할 수 있는 4가지 방법

- docker cp : 호스트에 위치한 파일을 구동중인 컨테이너 내부에 복사한다.
    - 형식 : `docker cp <호스트 경로> <컨테이너명>:<컨테이너 내부 경로>`
- Dockerfile ADD : 이미지는 Dockerfile을 기반으로 만들어지는데, 이때 Dockerfile에 ADD라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사된다.
    - 해당 이미지를 통해 구동한 컨테이너에서는 볷사한 파일을 사용할 수 있다.
    - 다만, 원하는 파일을 선택할 수는 없다.
- 바인드 마운트 : 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법
    - -v : 호스트 디렉토리와 컨테이너 디렉토리를 연결하는 옵션
    → `docker run -v <호스트 디렉토리 경로>:<컨테이너 디렉토리 경로>` 형식으로 사용한다.
    - 새로운 컨테이너를 구동할 때도 호스트와 연결할 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결이 가능
    - 호스트 디렉토리의 내용을 컨테이너 디렉토리에 그대로 덮어쓴다. 
    → 컨테이너 디렉토리에 있는 내용이 덮어써져 삭제될 수 있다.
- 볼륨 : 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결한다.
    - 바인드 마운트와 다르게 디렉토리를 동기화하는 방식이어서, 기존에 컨테이너 디렉토리에 있던 내용을 삭제하지 않는다. (덮어쓰지 않는다.)
    → 단, 동일한 파일이 있는 경우엔 해당 파일을 덮어쓰기를 한다.

## 컨테이너 정리하기

### 컨테이너 정지

- `docker stop <컨테이너 ID | NAMES>`
- `docker stop $(docker ps -q -f ancestor=nginx)`
    - -q : quite 옵션으로 id만 출력한다.
    - -f ancestor=nginx : nginx 이미지를 사용한 컨테이너만 필터링한다.

### 컨테이너와 이미지 삭제

- 컨테이너 삭제 : `docker rm <컨테이너 ID | NAMES>`
- 이미지 삭제 : `docker rmi <이미지 ID>`
- 컨테이너 삭제 후, 이미지까지 삭제해야 완전하게 용량을 확보할 수 있다.

# 컨테이너 이미지 만들기

## 기본 방법으로 빌드하기

자바 코드 → 메이븐으로 Jar 파일로 빌드

- `docker build -t <태그명> <경로>` 로 컨테이너 이미지를 빌드한다.
→ -t : tag 옵션으로, 만들어질 이미지를 의미한다.
- Dockerfile에 정의된 내용을 따라 이미지가 만들어진다.

```docker
FROM openjdk:8
EXPOSE 60431  
COPY ./target/app-in-host.jar /opt/app-in-image.jar
WORKDIR /opt
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]  
```

- FROM : `FROM <이미지명>:[태그]` 형식으로 이미지를 가져온다.
    - 가져온 이미지 내부에서 컨테이너 이미지를 빌드한다.
    → openjdk 이미지 위에서 작성중인 Dockerfile 내용을 적용한다?
- EXPOSE : 이미지로 컨테이너를 구동할 때 어떤 포트를 사용할지 알려준다.
    - 컨테이너를 구동할 때 해당 포트를 호스트 포트와 연결해주지는 않는다. 단지, 컨테이너의 어떤 포트를 연결해야한다는 정보만 제공할 뿐이다.
    - 실제로 외부에서 접속하려면 `docker run -p <호스트 포트>:<컨테이너 포트>` 명령을 통해 호스트와 컨테이너의 포트를 서로 연결해주는 작업이 필요하다.
- COPY : 호스트에서 새로 생성하는 컨테이너 이미지로 필요한 파일을 복사한다.
- WORKDIR : 이미지의 현재 작업 위치를 지정한 위치로 변경한다.
- ENTRYPOINT : 컨테이너 구동시 ENTRYPOINT 뒤에 나오는 대괄호 안의 명령을 실행한다.
    - ENTRYPOINT로 실행하는 명령어는 컨테이너를 구동할 때 첫번째로 실행된다.

## 컨테이너 용량 줄이기

Dockerfile의 `FROM` 부분을 openjdk에서 distroless라는 자바 실행을 위한 경량화된 이미지로 변경했다.

- 호스트에서 jar 파일을 빌드한 후에 (sh 파일), COPY를 통해 자바 실행만 하는 가벼운 distroless 이미지로 보냈다.
→ openjdk 이미지에 포함된 자바 개발 도구를 사용하지 않음으로써 용량을 줄였다.

## 컨테이너 내부 빌드

자바 소스를 컨테이너 이미지에서 빌드

```docker
...
RUN git clone https://github.com/iac-source/inbuilder.git  //git에서 소스코드를 내려받는다.
WORKDIR inbuilder   // 내려받은 디렉토리를 현재 작업 공간으로 지정
RUN chmod 700 mvnw  // 권한 설정
RUN ./mvnw clean package  // 이미지 내부에서 빌드 작업 수행
RUN mv target/app-in-host.jar /opt/app-in-image.jar  // mv로 파일 위치만 옮김(컨테이너 내부이므로 COPY 하지않는다)
WORKDIR /opt
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]
```

- 장점 : 편리하다.
→ Dockerfile 하나만 빌드하면 컨테이너가 바로 생성되어 편리하다.
- 단점 : 용량이 크다.
→ 컨테이너 내부에서 빌드를 진행하기 때문에, 빌드 중간에 생성한 파일들과 내려받은 라이브러리 캐시들이 이미지에 그대로 남아있게 되어 용량이 매우 커진다.

## 최적화해 컨테이너 빌드하기 - 멀티 스테이지 빌드

최종 이미지의 용량을 줄일 수 있고, 호스트에 어떤 빌드 도구도 설치할 필요가 없다.

- 빌드하는 위치와 최종 이미지를 분리한다.

```docker
# 1단계 - 자바 소스를 빌드해 JAR 파일을 만든다.
FROM openjdk:8 AS int-build   # 1번째 이미지로, int-build라는 별칭을 붙임
RUN git clone https://github.com/iac-source/inbuilder.git
WORKDIR inbuilder
RUN chmod 700 mvnw
RUN ./mvnw clean package

# 2단계 - 빌드된 JAR 파일을 경량화 이미지에 복사한다.
FROM gcr.io/distroless/java:8
EXPOSE 60434
COPY --from=int-build inbuilder/target/app-in-host.jar /opt/app-in-image.jar
# int-build(1단계의 openjdk)에서 빌드가 완료된 app-in-host.jar를 distroless에 /opt/app-in-image.jar로 복사한다.
WORKDIR /opt
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]
```

- 이 방법을 통해 위에 ‘컨테이너 용량 줄이기’ 실습에서 생성된 이미지와 같은 용량의 이미지를 얻을 수 있다.
- ‘컨테이너 용량 줄이기’ 실습에선 호스트에서 jar를 빌드했고, 이번 실습에선 컨테이너 내에서 빌드했다는 차이점이 있다.

→ ‘컨테이너 용량 줄이기’에서 openjdk 이미지 대신 distroless를 사용함으로써 용량을 줄였다. 이번 실습에선 openjdk와 distroless 이미지를 같이 사용하는데 어떻게 이미지 크기가 더 커지지 않는거지?
