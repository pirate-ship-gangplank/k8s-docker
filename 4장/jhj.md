## 4.1 도커를 알아야하는 이유

### 4.1.1 파드, 컨테이너, 도커, 쿠버네티스 관계

### 쿠버네티스 시스템

컨테이너 - 파드 - 노드(마스터 + 워커) - 클러스터

컨테이너 : 하나의 운영체제 안에서 커널을 공유하며 개별적인 실행환경을 제공하는 격리된 공간

개별적인 실행 환경 : cpu, network, memory와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환

개별적인 실행환경에서는 실행되는 프로세스를 구분하는 id도 컨테이너 안에 격리돼 관리한다.

(의문 -> 컨테이너 = 프로세스 라고 알고있었는데 이둘은 전혀다른 것이였나?)

따라서 각 컨테이너 내부에서 실행되는 애플리케이션들은 서로 영향을 미치지 않고 독립적으로 작동할 수 있다.

예전부터 유닉스나 리눅스에서는 하나의 호스트 운영체제 안에서 자원을 분리해 할당하고 프로세스를 격리하여 관리하는 방법을 제공하였지만 
파일 시스템을 설정, 자원과 공간을 관리하는 등의 복잡한 과정을 직접 수행해야하는 어려움이 존재

->이를 해결해주는 도구가 "도커"

### 4.1.2 다양한 컨테이너 관리 도구

 - 컨테이너 디
 - 크라이오
 - 카타 컨테이너
 - 도커

어짜피 도커를 공부할 예정이니 자세한 설명은 생략

## 4.2 도커로 컨테이너 다루기

### 4.2.1 컨테이너 이미지 알아보기

이미지는 registry라고 하는 저장소에 모여 있다.

이때 registry 는 공개된 유명 registry와 local registry 두가지 모두 해당된다.

* registry 검색 명령어
~~~
docker search <name>
~~~

* image 내려받기
~~~
docker pull <name>
~~~
- tag : 이미지를 내려받을 때 사용한 태그를 의미한다. default로 lastest가 적용되어서 가장 최신 이미지를 받도록 설정되어 있다
- layer: 하나의 이미지는 여러개의 레이어로 구성, 따라서 각각의 레어어가 다운로드 될 때마다 complete를 출력
- digest : 이미지의 고유 식별자, 이미지 내용과 생성환경을 식별할 수 있다. hash로 구성
- status : 이미지를 내려받은 레지스트리, 이미지, 태그 등의 정보를 확인 가능

### 이미지 태그

태그 : 이름이 동일한 이미지에 추가하는 식별자

이미지의 이름이 같더라도 버전이나 플랫폼(cpu종류나 기본베이스를 이루는 운영 체제 등)이 다를 수 있다.

default : lastest  ,안정화된 버전을 사용하고 싶다면: stable

~~~
docker pull nginx:stable
~~~

### image 레이어 구조
image이 애플리케이션과 각종 파일을 담고 있다는 점에서 zip 같은 압축 파일에 더 가깝다.

하지만 압축 파일과 다른 점은 같은내용의 경우 동일한 레이어를 공유하기 때문에 상대적으로 압축파일과 비교했을 때 차지하는 공간이
줄어든다.

### 4.2.2 컨테이너 실행하기
내려받은 이미지를 통해서 새로운 컨테이너를 실행해 어떤 구성을 가지는지 알아보자.

~~~
docker run -d --restart always nginx
~~~

위 명령어를 실행하면 16진수로 이루어진 문자열이 출력되는데 이는 컨테이너를 식별할 수 있는 고유 id이다.

명령어 형식은
~~~
docker run [option] <image name>[:tag | @digest]
~~~
이고 태그와 다이제스트는 생략 가능하다.

### 옵션
 - "-d", "--detach" : container를 백그라운드로 구동한다는 의미이다. 이 옵션을 생략하면 컨테이너 내부 애플리케이션의 상태가 화면에 계속
출력이 되는데 이를 나가기 위해서 ctrl + c를 사용하면 컨테이너도 함께중단한다. 따라서 계속 작동해야하는 서버나 데이터베이스 같은 프로그램은 -d 옵션을 붙여서 백그라운드로 작동하게 해야한다.
 - "--restart always": 컨테이너 재시작과 관련된 정책으르 의미하는 옵션, 프로그램에 예상하지 못한 오류가 발생하거나 리눅스 시스템에서 도커 서비스가 중지되는 경우에 컨테이너도 작동 중지, 이대 중지된 컨테이너를 즉시 재시작하거나 리눅스 시스템에서 도커 서비스가 작동할 때 컨테이너를 자동 시작하도록 설정 가능
 - "-p <요청 받을 호스트 포트>:<연결할 컨테이너 포트>" : 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션


### 4.2.3 컨테이너 내부 파일 변경하기
컨테이너 내부에서 외부 파일을 사용할 수 있는 4가지 방법
1. docker cp : host에 위치한 파일을 구동 중인 컨테이너 내부에 복사합니다. 따라서 컨테이너에 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해서 사용, 또는 컨테이너에 저장돼 있는 설정 및 로그를 추출해 확인하는 목적으로도 사용
~~~
docker cp <host path><container name>:<container inner path> 
~~~
2. Dockerfile ADD : 이미지는 dockerfile을 기반으로 만들어지는데, 이때 dockerfile에 add라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지 빌드때 지정한 파일이 이미지 내부로 복사,
3. 바인드 마운트 : 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법, 주로 컨테이너가 바뀌어도 없어지면 안되는 자료를 이 방법으로 보존 가능
4. 볼륨: 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일, but 호스트의 특정 디렉이 아닌 도커가 관리하는 볼륨을 컨테이너와 연결.

주로 사용되는 방법은 3,4 번이다. 

바인드 마운트의 특징 : 호스트의 특정 디렉과 컨테이너 내부와 연결할 때에 호스트 디렉의 내용이 컨테이너 내부에 덮어쓰기 된다.따라서 호스트 디렉이 비어있다면 기존에 있던 파일들이 다 삭제되고 빈 디렉이 마운트 된다는 점을 명심하자.
볼륨을 사용할 때 특징 : 바인드 마운트와 다르게 호스트 디렉을 덮어쓰는 것이 아닌 양쪽을 서로 동기화시키는 구조 따라서 비어있는 볼륨으로 연결하는 경우 컨테이너 디렉이 보존된다.
but 동일한 이름의 파일에 대해서는 덮어쓰기되니 유의가 필요

### 4.2.4 사용하지 않는 컨테이너 정리
~~~
docker stop <container name | id>
~~~
컨테이너가 정지되면 컨테이너 이름이 결과로 표시된다.

같은 이미지를 사용하는 모든 컨테이너를 한번에 끄기 위해서는 

~~~
docker stop $(docker ps -q -f ancestor=nginx)
~~~

nignx를 사용하는 모든 컨테이너를 정지하는 명령어이다.

컨테이너를 모두 정지된건 맞지만 삭제되지는 않았다 컨테이너를 정지만하고 삭제는 안해도 되지만 다시 사용하지 않을 거라면 메모리 공간을 많이 차지하기 때문에 꼭 삭제하길 바란다.

~~~
docker rm $(docker ps -q -f ancester=nginx)
~~~
컨테이너를 정지하는 것과 마찬가지로 응용을 하면 삭제도 편리하게 할 수 있다.

여기서 끝이 아니다! 더이상 필요없는 이미지는 삭제까지 해야한다. 안그러면 용량 차지를 많이 하게 된다.

~~~
docker rmi $(docker ps -q nginx)
~~~


## 4.3 4가지 방법으로 컨테이너 이미지 만들기
1. 기본적인 빌드
2. 용량 줄이기
3. 컨테이너 내부 빌드
4. 멀티 스테이지

### 4.3.1 기본적인 빌드

순서 
1. 자바소스 빌드
2. 도커 파일 작성
3. 도커파일 빌드 
4. 빌드 완료

Dockerfile을 작성하여 이미지를 생성
이를 컨테이너화 하여 실행


### 4.3.2 컨테이너 용량 줄이기
불필요한 공간을 점유하는 것은 성능에 영향을 미칠 수도 있다. 

기본적인 빌드에서 한단계 줄었다.
1. 도커 파일 작성
2. 도커 파일 빌드
3. 빌드 완료

기초 이미지가 openjdk에서 gcr에서 제공하는 distroless로 변경된다.

처음에 openjdk이미지를 설치할 때 호스트에 자바 개발도구도 같이 설치 하지만 이는 불필요하게 낭비되는 공간을 줄임

### 4.3.3 컨테이너 내부에서 컨테이너 빌드
다른 방법과 달리 도커파일 하나만 있으면 이미지를 생성 할 수 있다.

1. 도커 파일 작성
2. 도커파일 빌드
3. 빌드 완료

특이점은 컨테이너 내부에서 빌드한다는 것이다. 이 방법은 컨텡너 내부에서 빌드가 진행되어 이미지 용량이 다른 방법에 비해서 커지는데 이는 그다지 좋은 방법이 아니다.
하지만 도커 파일 하나만 가지고 이미지를 만든다는 편리함은 매력적이다.

### 4.3.4 최적화해 컨테이너 빌드하기
멀티 스테이지 빌드
1. 도커파일 작성
2. 도커파일 빌드
3. 빌드 완료

(docker-ce 17.06부터 멀티 스테이지를 지원)

빌드하는 위치와 최종 이미지를 분리하는 것이 핵심

자바 소스를 빌드하는 이미지와 jar을 가지고 있는 이미지를 구분하여서 빌드하는 방식으로 보인다. 이때 소스를 빌드하는 이미지를 댕들링이라고 부르는 데 이는 그냥 삭제하면 된다.

## 4.4 쿠버네티스에서 직접 만든 컨테이너 사용하기
### 4.4.1 쿠버네티스에서 도커 이미지 구동하기

기본적으로 쿠버네티스는 외부 이미지파일을 사용하려고 한다.따라서 외부 이미지가 아닌 내부 이미지를 사용하기 위해서는 도커허브에 이미지를 올려서 다시 내려받거나 쿠버네티스 클러스터가 접근할
수 있는 곳에 이미지 레지스트리를 만들고 그 곳에서 받아오도록 설정해야한다.

### 4.4.2 레지스트리 구성하기
도커 레지스트리 이미지를 사용해 사살 도커 레지스트리를 만들겠다.
특징으로 기능은 부족하지만 컨테이너 하나만 구동하면 설치가 간편하고 내부에서 테스트 목적으로 사용하기 적합

ex) Quay, Harbor, Nexus Repository, Docker registry

registry 이미지를 컨테이너화 시키고 이를 레지스트리 이름에 맞게 태그를 한다. 그러면 이미지가 하드링크로 파일이 하나 더 생기게 되고 push 명령어를 사용하여 registry를 사용하면 된다.

### 4.4.3 직접만든 이미지로 컨테이너 구동하기
이전에 만든 registry에 접속하여서 안에 저장된 이미지를 가지고 컨테이너를 구동하면 된다.















