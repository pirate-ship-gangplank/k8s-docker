## 4장 : 쿠버네티스를 이루는 컨테이너 도우미, 도커

쿠버네티스는 컨테이러를 오케스트레이션하며, 오케스트레이션하는 기본 단위 = 파드

> "오케스트레이션" : 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것



## 4.1 : 도커를 알아야 하는 이유

쿠버네티스를 이루는 기본 오브젝트가 파드고,
파드는 컨테이너로 이루어져 있으며,
컨테이너를 만들고 관리하는 도구가 도커입니다

### 4.1.1 : 파드, 컨테이너, 도커, 쿠버네티스의 관계

- 쿠버네티스 시스템

파드들은 워커 노드라는 노드 단위로 관리하며, 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터가 됩니다
그리고 파드는 1개 이상의 컨테이너로 이루어져 있습니다

파드는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공합니다
그리고 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 합니다

> 컨테이너를 돌보는 것이 파드, 파드를 돌보는 것이 쿠버네티스 워커 노드, 워커 노드를 돌보는 것이 쿠버네티스 마스터 (쿠버네티스 마스터 또한 파드로 이루어져 있습니다)

**컨테이너**는 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간입니다

> 개별적인 실행 환경 : CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경

이를 통해 각 컨테이너 내부에서 실행되는 애플리케이션들은 서로 영향을 미치지 않고 독립적으로 작동할 수 있습니다

### 4.1.2 : 다양한 컨테이너 관리 도구

|구분|컨테이너디|크라이오|카타 컨테이너|도커|
|---|---|---|---|---|
|명령어 도구|별도 지원|타 도구 사용|자체 지원|자체 지원|
|내부 구조|단순|매우 단순|복잡|복잡|
|확장성|좋음|좋지 못함|좋지 못함|매우 좋음|
|컨테이너 관리|좋음|좋음|좋음|매우 좋음|
|이미지 관리|좋음|좋음|좋음|매우 좋음|
|보안성|좋음|좋음|매우 좋음|좋음|
|자원 사용량|매우 좋음|매우 좋음|좋지 못함|좋음|
|정보량|적음|거의 없음|거의 없음|매우 많음|

## 4.2 : 도커로 컨테이너 다루기

### 4.2.1 : 컨테이너 이미지 알아보기

- 이미지 태그

**태그**는  이름이 동일한 이미지에 추가하는 식별자입니다
이름이 동일해도 도커 이미지의 버전이나 플랫폼(CPU 종류나 기본 베이스를 이루는 운영 체제 등)이 다를 수 있기 때문에 이를 구분하는 데 사용합니다

이미지 버전이 올라가면서 추가 또는 변경되는 기능에 따라 예상치 못한 오류가 생길 수 있습니다
이에 따라 컨테이너를 배포할 때는 latest 태그가 아닌 검증된 버전으로 배포해야 문제가 생기지 않습니다

- 이미지 레이어 구조

이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 ZIP 같은 압축 파일에 더 가깝습니다
압축 파일은 압축한 파일의 개수에 따라 전체 용량이 증가하지만,
이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유하므로 전체 용량이 감소합니다
이와 같은 이유로 도커로 작성된 컨테이너는 여러 이미지를 내려받더라도 디스크 용량을 효율적으로 사용할 수 있습니다

### 4.2.2 : 컨테이너 이미지 알아보기

- docker run

docker run 명령어를 사용해서 컨테이너를 실행시킬 수 있습니다
여기서 나온 16진수 문자열은 컨테이너를 식별할 수 있는 고유한 ID입니다

```
-d(--detach) : 컨테이너를 백그라운드에서 구동한다는 의미입니다

--restart always : 예상치 못한 오류가 발생하거나 리눅스 시스템에서 도커 서비스가 중지되는 경우에 컨테이너가 중지되는데, 
즉시 재시작하거나 리눅스 시스템에서 도커 서비스가 작동할 때 컨테이너를 자동으로 시작하도록 설정할 수 있습니다

-p 8080:80 : 8080번 포트로 들어오는 요청을 컨테이너 내부의 80번 포트로 전달한다는 의미

--name nginx-exposed : 현재 작동 중인 컨테이너 이름
```

- docker ps

생성한 컨테이너 상태를 확인할 수 있습니다

```
-f id=? : id 문자열이 포함되어 있는 컨테이너 출력
```

> 컨테이너는 변경 불가능한 인프라를 지향합니다
> 
> 따라서 컨테이너는 적용된 설정을 변경하려면 새로운 컨테이너를 생성해야 합니다
> 
> 이러한 특성 덕분에 컨테이너로 배포된 인프라는 배포된 상태를 유지한다는 장점이 있습니다

### 4.2.3 컨테이너 내부 파일 변경하기

- docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로>

호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사합니다

- Dockerfile ADD

이미지는 Dockerfile을 기반으로 만들어지는데, 이때 Dockerfile에 ADD 라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면
이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사됩니다

- 바인드 마운트

호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법입니다
호스트 디렉터리 -> 컨테이너 디렉터리

- 볼륨

호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 
호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결합니다

```shell
> docker exec <컨테이너의 ID | 이름> <명령어>

컨테이너에서 명령을 실행하고 결과를 보여 줍니다
```

### 4.2.4 사용하지 않는 컨테이너 정리하기

```shell
> docker stop <이름>

실행중인 컨테이너를 정지하는 명령

> docker stop $(docker ps -q -f ancestor=nginx)

nginx 를 이미지로 사용하는 모든 컨테이너를 정지

> docker ps -a -f ancestor=nginx

정지된 컨테이너를 포함해 nginx 이미지를 기반으로 생성한 컨테이너 모두 조회

> docker rm $(docker ps -aq -f ancestor=nginx)

컨테이너 삭제 명령어

> docker rmi $(docker images -q nginx)

이미지 삭제 명령어

```

## 4.3 : 4가지 방법으로 컨테이너 이미지 만들기

- 컨테이너 이미지 생성 방법

기본적인 빌드 - 용량 줄이기 - 컨테이너 내부 빌드 - 멀티 스테이지

### 4.3.1 : 기본 방법으로 빌드하기

- 기본적인 컨테이너 빌드 과정

자바 소스 빌드 - 도커파일 작성 - 도커파일 빌드 - 빌드 완료

```shell
> docker build

컨테이너 이미지 빌드
```

도커파일은 빌드용 DSL(Domain-Specific Languages)로 작성된 파일입니다

|구분|도커 파일 내용|배시 명령으로 유사 해석|
|---|---|---|
|1|FROM openjdk:8|import openjdk:8 image|
|2|LABEL description="Echo IP Java Application"|Label_desc="Echo IP Java Applicaion" (컨테이너 설명)|
|3|EXPOSE 60431|EXPOSE=60431 (60431 포트를 사용해 오픈하도록 설명)|
|4|COPY ./target/app-in-host.jar /opt/app-in-image.jar|scp <HOST>/target/app-in-host.jar <Image>/opt/app-in-image.jar|
|5|WORKDIR /opt|cd /opt|
|6|ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ] | ./java -jar app-in-image.jar|

### 4.3.4 : 최적화해 컨테이너 빌드하기

- 멀티 스테이지 빌드

도커파일 작성 - 도커파일 빌드 - 빌드 완료

최종 이미지의 용량을 줄일 수 있고 호스트에 어떠한 빌드 도구도 설치할 필요가 없습니다

1단계 : 자바 소스를 빌드해 JAR로 만듦
  
2단계 : 빌드된 JAR을 경량화 이미지에 복사

이름이 없는 이미지를 댕글링 이미지라고 합니다
  
멀티 스테이지 과정에서 자바 소스를 빌드하는 과정에 생성된 이미지로 보면 됩니다
  
공간을 적게 사용하는 이미지를 만드는 것이 목적이므로 댕글링 이미지를 삭제합니다

## 4.4 : 쿠버네티스에서 직접 만든 컨테이너 사용하기

### 4.4.1 : 쿠버네티스에서 도커 이미지 구동하기

```shell
디플로이먼트 생성할때 기본 설정은 이미지를 외부에서 받으려고 합니다 (도커 허브)

사용자가 원하는 형태의 디플로이먼트를 만드는 가장 좋은 방법은 현재 수행되는 구문을 야믈 형태로 뽑아내는 것

> kubectl create deployment <이름> --dry-run=client -o yaml

--dry-run=client : 해당 내용을 실제로 적용하지 않는채 명령을 수행
-o yaml : 현재 수행되는 명령을 야믈 형태로 바꿉니다

yaml 파일에 imagePullPolicy : Never 옵션을 추가해서 외부에서 이미지를 가져오지 않고 호스트에 존재하는 이미지를 사용하게 합니다

```

### 4.4.2 : 레지스트리 구성하기

인터넷이 연결돼 있다면 도커 허브를 사용할 수 있지만,
여러가지 제한 사항이 있습니다

이를 위해 도커 레지스트리 이미지를 사용해 사설 도커 레지스트리를 만들 수 있습니다

|구분|키|하버|넥서스 리포지터리|도커 레지스트리|
|---|---|---|---|---|
|가격|유/무료|무료|유/무료|무료|
|저장 형식|도커 이미지, 헬름|도커 이미지, 헬름|다양함|도커 이미지|
|설치 방법|직접 설치, 클라우드|직접 설치|직접 설치|직접 설치|
|기능|부가 기능 있음|부가 기능 있음|매우 많음|최소|
|관련 자료|적음|보통|많음|많음|

