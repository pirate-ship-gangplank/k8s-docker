# 3장 : 컨테이너를 다루는 표준 아키텍처, 쿠버네티스

- 컨테이너 인프라 환경이란?
```json
리눅스 운영 체제의 커널 하나에서 여러 개의 컨테니어가 격리된 상태로 실행되는 인프라 환경
```
개인 환경에서는 1명의 관리자가 다양한 응용프로그램을 사용하므로 각각의 프로그램을 컨테이너로 구현할 필요는 없습니다

하지만, 기업 환경에서는 다수의 관리자가 많은 양의 서버를 함께 관리하기 때문에 **일관성**을 유지하는 것이 매우 중요합니다

기존에는 컨테이너 인프라 환경이 주는 장점이 많았지만, 컨테이너 관리 문제가 까다로워서 보편화되기 어려웠습니다

여기서, **쿠버네티스**가 등장하면서 컨테이너 인프라 환경을 좀 더 효율적으로 관리할 수 있게 됐습니다

이를 계기로 여러 기능들이 계속 추가되면서 쿠버네티스의 생태계가 풍부해졌고, 사실상 쿠버네티스는 컨테이너 인프라 관리 솔루션의 표준이 되었습니다

## 3.1 : 쿠버네티스 이해하기

- 쿠버네티스
```json
"컨테이너 오케스트레이션"을 위한 솔루션

"오케스트레이션" : 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것

```

다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어주는 것이 컨테이너 오케스트레이션입니다

### 3.1.1 : 왜 쿠버네티스일까

|구분|도커 스웜|메소스|노매드|쿠버네티스|
|---|---|---|---|---|
|설치 난이도|쉬움|매우 어려움|쉬움|어려움|
|사용 편의성|매우 좋음|좋음|매우 좋음|좋음|
|세부 설정 지원|거의 없음|있음|거의 없음|다양하게 있음|
|안정성|매우 안정적임|안정적임|안정적이|매우 안정적임|
|확장성|어려움|매우 잘 됨|어려움|매우 잘 됨|
|정보량|많음|적음|적음|매우 많음|
|에코 파트너|없음|거의 없음|있음|매우 많음|
|학습 곡선|쉬움|매우 어려움|어려움|어려움|

다양한 형태의 쿠버네티스가 지속적으로 계속 발전되고 있어서 컨테이너 오케스트레이션을 넘어 IT 인프라 자체를 컨테이너화하고,

컨테이너화된 인프라 제품군을 쿠버네티스 위에서 동작할 수 있게 만듭니다

즉, 거의 모든 벤더와 오픈 소스 진영 모두에서 쿠버네티스를 지원하고 그에 맞게 통합 개발하고 있습니다

### 3.1.2 : 쿠버네티스 구성 방법

|구분|KRIB|kops|kubespray|kubeadm
|---|---|---|---|---|
|정보량|적음|많음|많음|매우 많음|
|세부 설정 변경|가능함|가능함|제한적으로 가능함|다양함|
|사전 요구 조건|적음|적음|적음|매우 적음|
|온프레미스 지원|매우 좋음|안 됨|좋음|매우 좋음|
|클라우드 지원|안 됨|매우 좋음|좋음|좋음|
|학습 곡선|매우 어려움|어려움|쉬움|어려움|
|자동화 기능|제공됨|제공됨|쉽게 제공됨|제한적으로 제공됨|

### 3.1.4 : 파드 배포를 중심으로 쿠버네티스 구성 요소 살펴보기

- 파드    

> 파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.

[파드란 무엇긴가?](https://kubernetes.io/ko/docs/concepts/workloads/pods/)

파드를 배포하는 순서

####마스터 노드

-  kubectl : 쿠버네티스 클러스터에 명령을 내리는 역할
   

-  API 서버 : 쿠버네티스 클러스터의 중심 역할을 하는 통로 (회사에 비유하면 모든 직원과 상황을 관리하고 목표를 설정하는 관리자)
   

-  etcd : 구성 요소들의 상태 값이 모두 저장되는 곳 (etcd의 정보만 백업돼 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스터는 복구할 수 있다)


-  컨트롤러 매니저 : 쿠버네시트 클러스터의 오프젝트 상태 관리 (워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구를 담당)


-  스케줄러 : 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지 결정 및 할당


####워커 노드

-  kubelet : 파드의 구성 내용을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링

-  컨테이너 런타임 : 파드를 이루는 컨테이너의 실행을 담당

-  파드 : 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위 (언제라도 죽을 수 있는 존재)

### 3.1.5 : 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기

쿠버네티스의 가장 큰 장점은 구성 요소마다 하는 일이 명확하게 구분돼 각자의 역할만 충실하게 수행하면 클러스터 시스템이 안정적으로 운영된다는 점입니다.

역할이 나뉘어 있기에 MSA 구조와도 밀접하게 연관되고, 어느 부분에서 문제가 발생했는지 디버깅하기 쉽습니다

#### 파드의 생명주기

1. kubectl 을 통해 API 서버에 파드 생성 요청
2. (업데이트가 있을 때마다 매번) API 서버에 전달된 내용이 있으면 API 서버는 etcd 에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지
3. API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지하면 파드를 생성하고, 이 상태를 API 서버에 전달 (어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태)
4. API 서버에 파드가 생성됐다는 정보를 스케줄러가 인지, 어떤 워커 노드에 적용할지 조건을 고려해 결정
5. API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 스케줄러가 kubelet 으로 확인
6. kubelet 에서 컨테이너 런타임으로 파드 생성 요청
7. 파드 생성
8. 파드가 사용 가능한 상태

쿠버네티스는 작업을 순서대로 진행하는 워크플로 구조가 아니라 선언적인 시스템 구조를 가지고 있습니다

**즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조**

## 3.2 : 쿠버네티스 기본 사용법 배우기

### 3.2.1 : 파드를 생성하는 방법

쿠버네티스를 사용한다는 것은 결국 사용자에게 효과적으로 파드를 제공한다는 뜻입니다

- 파드 생성 명령어

```shell
kubectl run nginx-pod --image=nginx
```
--image=nginx 는 생성할 이미지의 이름

- 파드 확인 명령어

```shell
kubectl get pod
```

####run과 create deployment로 파드를 생성하 것의 차이는?

run으로 파드를 생성하면 단일 파드 1개만 생성되고 관리됩니다

create deployment로 파드를 생성하면 디플로이먼트라는 관리 그룹 내에서 파드가 생성됩니다

> run : 초코파이 1개, create deployment : 초코파이 상자 속에 있는 초코파이 1개

### 3.2.2 : 오브젝트란

쿠버네티스를 사용하는 관점에서 파드와 디플로이먼트는

**스펙**과 **상태** 등의 값을 가지고 있습니다

이러한 값을 가지고 있는 파드와 디플로이먼트를 개별 속성을 포함해 부르는 단위를 오브젝트라고 합니다

#### 기본 오프젝트

- 파드 
  
쿠버네티스에서 실행되는 최소 단위, 웹 서비스를 구동하는 데 필요한 최소 단위
독립적인 공간과 사용 가능한 IP를 가지고 있습니다

- 네임스페이스

쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹

- 볼륨

파드가 생성될 때 파드에서 사용할 수 있는 디렉터리를 제공합니다

파드가 사라지더라도 저장과 보존이 가능한 디렉터리를 볼륨 오브젝트를 통해 생성하고 사용할 수 있습니다

- 서비스

파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정일 수 없습니다

쿠버네티스 외부에서 쿠버네티스 내부로 접속할 때 내부가 어떤 구조로 돼 있는지, 파드가 살았는지 죽었는지 신경 쓰지 않아도 이를 논리적으로 연결하는 서비스입니다

#### 디플로이먼트

기본 오프젝트만으로도 쿠버네티스를 사용할 수 있지만, 한계가 있어서 좀 더 효율적으로 작동하도록 기능들을 조합하고 추가한 것이 디플로이먼트입니다

### 3.2.3 : 레플리카셋으로 파드 수 관리하기

많은 사용자를 대상으로 웹 서비스를 하려면 다수의 파드가 필요한데, 이를 하나씩 생성하면 매우 비효율적입니다

그래서 쿠버네티스에서는 다수의 파드를 만드는 레플리카셋 오브젝트를 제공합니다

```shell
kubectl scale deployment dpy-nginx --replicas=3
```

### 3.2.4 : 스펙을 지정해 오브젝트 생성하기

create 에서는 1개의 파드만 생성이 됩니다

create 에서는 replicas 옵션을 사용할 수 없고, scale 은 이미 만들어진 디플로이먼트에서만 사용할 수 있습니다

이런 설정을 적용하기 위해 파일을 작성하는데, 이때 파일을 **오브젝트 스펙**이라고 합니다

create deployment 를 생성하면 파일의 밴경 사항을 바로 작용할 수 없다는 단점이 있습니다

배포된 오브젝트의 스펙을 변경하고 싶을 때는 지우고 다시 만드는 방법밖에 없을까요?


### 3.2.5 : 스펙을 지정해 오브젝트 생성하기

이런 경우를 위해 쿠버네티스는 apply 라는 명령어를 제공합니다

이처럼 변경사항이 예상 되는 오브젝트는 처음부터 apply 로 생성하는 것이 좋습니다

|구분|Run|Create|Apply|
|---|---|---|---|
|명령 실행|제한적임|가능함|안 됨|
|파일 실행|안 됨|가능함|가능함|
|변경 가능|안 됨|안 됨|가능함|
|실행 편의성|매우 좋음|매우 좋음|좋음
|기능 유지|제한적임|지원됨|다양하게 지원됨|

### 3.2.6 : 파드의 컨테이너 자동 복구 방법

쿠버네티스는 거의 모든 부분이 자동 복구되도록 설계됐습니다

파드의 자동 복구 기술을 **셀프 힐링**이라고 하는데, 제대로 작동하지 않는 컨테이너를 다시 시작하거나 교체해 파드가 정상적으로 작동하게 합니다

- 컨테이너 쉘 접속 명령어

```shell
kubectl exec -it nginx-pod -- /bin/bash
```

### 3.2.8 노드 자원 보호하기

쿠버네티스는 모든 노드에 균등하게 파드를 할당하려고 gkqslek
문제가 생길 가능성이 있는 노드라는 것을 쿠버네티스에 알려주기 위해서 cordon 기능을 사용합니다

```shell
kubectl cordon w3-k8s
```

설헝 해제

```shell
kubectl uncordon w3-k8s
```

### 3.2.9 노드 유지보수하기

drain 은 지정된 노드의 파드를 전부 다른 곳으로 이동시켜 해당 노드를 유지보수할 수 있게 합니다

파드는 언제라도 삭제할 수 있기 때문에 쿠버네티스에서 대부분 이동은 파드를 지우고 다시 만드는 과정

DaemonSet은 각 노드에 1개만 존재하는 파드라서 drain 으로 삭제할 수 없습니다 (--ignore-daemonsets 를 사용하면 무시할 수 있습니다)

```shell
> kubectl drain w3-k8s --ignore-daemonsets
```

uncordon 명령을 실행해 스케줄을 받을 수 있는 상태로 복귀시킬 수 있다


### 3.2.10 파드 업데이트하고 복구하기

record 옵션으로 배포한 정보의 히스토리를 기록할 수 있습니다
record 옵션으로 기록된 히스토리는 rollout history 명령으로 확인할 수 있습니다

```shell
kubectl apply -f rollout-nginx.yaml --record
kubectl rollout history deployment rollout-nginx
```

set image 명령으로 파드의 컨테이너 버전을 업데이트 할 수 있습니다
record를 명령에 포함해 실행한 명령을 기록합니다
```shell
kubectl set image deployment rollout-ngingx nginx=nginx:1.16.0 --record
```

describe 명령으로 문제점을 좀 더 자시헤 볼 수 있습니다
describe 명령은 쿠버네티스의 상태를 살펴볼 때 유용합니다
````shell
kubectl describe deployment rollout-nginx
````

rollout undo로 명령 실행을 취소해 마지막 단계에서 전 단계로 상태를 되돌릴 수 있습니다
```shell
kubectl rollout undo deployment rollout-nginx
```

바로 전 상태가 아니라 특정 시점으로 돌아가고 싶다면

--to-revision 옵션을 이용해서 돌아갈 수 있습니다

```shell
kubectl rollout undo deployment rollout-nginx --to-revision=1
```