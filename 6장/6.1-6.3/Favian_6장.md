## 6장 : 안정적인 운영을 완성하는 모니터링, 프로메테우스와 그라파나

젠킨스로 쿠버네티스 애플리케이션 빌드와 배포를 자동화해 컨테이너 환경에 배포된 애플리케이션은 충분히 검증을 거친 상태지만,

상용 환경에서는 여러 가지 예외 상황이 발생할 수 있습니다

예를 들어 노드에서 하드웨어적으로 문제가 생기거나 컨테이너 관점에서 가용하는 리소스보다 많은 요청이 발생해 문제가 생기는 경우가 있을 수 있습니다

이를 위해 구축한 환경 자체를 모니터링하고, 문제가 생길 경우 적절한 조치를 빠르게 취해야 합니다

## 6.1 : 컨테이너 인프라 환경 모니터링하기

```shell
> bpytop : 시스템 상태 정보 조회

리소스의 상태 및 문제가 될 가능성이 있는 정보를 한눈에 파악

하지만, bpytop은 현재 노드에 대한 정보를 보여줄 뿐, 다수의 노드로 구성된 클러스터 정보를 모두 표현하기에는 한계가 있습니다
이러한 정보를 수집하고 분류해서 따로 저장해야 합니다

모니터링 도구는 수집 -> 통합 -> 시각화 구조로 되어 있습니다
```

모니터링 데이터를 프로메테우스로 **수집**하고 수집한 정보를 한곳에 모아(**통합**), 그라파나로 **시각화**합니다

### 6.1.1 : 모니터링 도구 선택하기

프로메테우스와 그라파나의 혼합 구조를 사용하는 이유는 크게 2가지 입니다

- 비용

모니터링 대상마다 라이선스 관련 비용이 발생하고, 클라우드 같은 과금제 서비스를 이용하면 네트워크와 저장 공간에 따른 추가 비용이 발생합니다

그래서 비용에 민감한 조직에는 도입하기 어렵습니다

- 보안

서비스형 모니터링 도구들은 대부분 외부에 데이터를 저장해 모니터링합니다

보안에 민감해서 내부에서 모든 데이터를 처리하려는 경우에는 사용하기 어렵습니다

#### 데이터 수집과 통합 도구

| 구분       | 프로메테우스 | 데이터독  | 뉴 렐릭 | 인플럭스DB   |
|----------|--------|-------|------|----------|
| 가격       | 무료     | 유료    | 유료   | 유/무료     |
| 형태       | 설치형    | 서비스형  | 서비스형 | 서비스형/설치형 |
| 참고 자료    | 매우 많음  | 많음  | 많음   | 많음       |
| 기능 확장성 | 매우 좋음  | 좋음 | 좋음   | 좋음         |

```shell
메트릭이란?

시스템의 상태를 알 수 있는 '측정값'

시스템 메트릭 : CPU와 메모리 사용량을 나타냄
서비스 메트릭 : HTTP 상태 코드 같은 서비스 상태를 나타내는 지표

시계열 데이터베이스란?

시간을 축으로 시간의 흐름에 따라 발생하는 데이터를 저장하는 데 최적화된 데이터베이스
```

#### 데이터 시각화 도구

| 구분     | 그라파나        | 키바나      | 크로노그래프   |
|--------|-------------|----------|----------|
| 가격     | 유/무료        | 유/무료     | 유/무료     |
| 형태     | 서비스형/설치형    | 서비스형/설치형 | 서비스형/설치형 |
| 시각화 대상 | 다양한 대상 시각화 가능 | 엘라스틱서치   | 인플럭스DB   | 
| 정보량    | 많음        | 많음       | 적음       |
| 기능 확장성 | 좋음        | 좋음       | 적음       |

### 6.1.2 : 쿠버네티스 환경에 적합한 모니터링 데이터 수집 방법

개발자가 작성한 애플리케이션 코드를 소스 코드 저장소에 푸시하면,

쿠버네티스 내부에 설치된 젠킨스는 애플리케이션 코드를 빌드하고 레지스트리에 푸시한 후에 쿠버네티스에서 사용 가능한 형태로 배포합니다

컨테이너 인프라 환경에서 젠킨스를 사용하는 주된 이유는 애플리케이션을 컨테이너로 만들고 배포하는 과정을 자동화하기 위해서입니다

젠킨스는 컨트롤러와 에이전트 형태로 구성한 다음 배포해야 하며 여기에 필요한 설정을 모두 넣어야 합니다

애플리케이션을 배포하기 위한 환경을 하나하나 구성하는 것은 매우 복잡하고 번거로운 일이며,

고정된 값이 아니기 때문에 매니페스트로 작성해 그대로 사용할 수가 없습니다

구성 환경에 따라 많은 부분을 동적으로 변경해야 합니다

## 5.2 : 젠킨스 설치를 위한 간편화 도구 살펴보기

### 5.2.1 : 배포 간편화 도구 비교하기

|구분|큐브시티엘|커스터마이즈|헬름|
|---|---|---|---|
|설치 방법|쿠버네티스에 기본 포함|별도 실행 파일 또는 쿠버네티스에 통합|별도 설치|
|배포 대상|정적인 야믈 파일|커스터마이즈 파일|패키지(차트)|
|주 용도|오브젝트 관리 및 배포|오브젝트의 가변적 배포|패키지 단위 오브젝트 배포 및 관리|
|가변적 환경|대응 힘듦(야믈 수정 필요)|간단한 대응 가능|복잡한 대응 가능|
|기능 복잡도|단순함|보통|복잡함|

### 5.2.2 : 커스터마이즈로 배포 간편화하기

커스터마이즈는 야믈 파일에 정의된 값을 사용자가 원하는 값으로 변경할 수 있습니다

쿠버네시트에서 오브젝트에 대한 수정 사항을 반영하려면 사용자가 직접 야믈 파일을 편집기 프로그램으로 수정해야 합니다

만약 수정해야 하는 야믈 파일이 매우 많거나 하나의 야믈 파일로 환경이 다른 여러 개의 쿠버네티스 클러스터에 배포해야 해서

LABEL 이나 NAME 같은 일부 항목을 수정해야 한다면 매번 일일이 고치는 데 많은 노력이 듭니다

커스터마이즈는 이를 위해 kustomize 명령을 제공합니다

kustomize 명령과 create 옵션으로 kustomization.yaml 이라는 기본 매니페스트를 만들고, 이 파일에 변경해야 하는 값들을 적용합니다

### 5.2.3 : 헬름으로 배포 간편화하기

헬름을 통한 배포는 커스터마이즈에서 제한적이었던 주소 할당 영역과 같은 값을 대체하면서 단단하게 설치할 수 있도록 설계돼 있습니다

쿠버네티스에 패키지를 손쉽게 배포할 수 있도록 패키지를 관리하는 쿠버네티스 전용 패키지 매니저입니다

실행 파일뿐만 아니라 실행 환경에 필요한 의존성 파일과 환경 정보들의 묶음입니다

그리고 패키지 매니저는 외부에 있는 저장소에서 패키지 정보를 받아와 패키지를 안정적으로 관리하는 도구입니다

패키지 매니저는 다양한 목적으로 사용되지만, 가장 중요한 목적은 설치에 필요한 의존성 파일들을 관리하고 간편하게 설치할 수 있도록 도와주는 것입니다

- 플랫폼별 패키지 매니저

|플랫폼|패키지 매니저|저장소|사용 목적|
|---|---|---|---|
|리눅스|yum, apt|배포판 저장소|소프트웨어 의존성 관리|
|파이썬|pip|pypi.org|파이썬 모듈 의존성 관리|
|자바|maven|mvnrepository.com|자바 라이브러리 의존성 관리|
|쿠버네티스|helm|artifacthub.io|쿠버네티스 패키지 관리|

- 패키지 매니저의 기능
    - 패키지 검색 : 설정한 저장소에서 패키지를 검색하는 기능을 제공합니다
    - 패키지 관리 : 저장소에서 패키지 정보를 확인하고, 사용자 시스템에 패키지 설치, 삭제, 업그레이드, 되돌리기 등을 할 수 있습니다
    - 패키지 의존성 관리 : 패키지를 설치할 때 의존하는 소프트웨어를 같이 설치하고, 삭제할 때 같이 삭제할 수 있습니다
    - 패키지 보안 관리 : 디지털 인증서와 패키지에 고유하게 발행되는 체크섬이라는 값으로 해당 패키지의 소프트웨어나 의존성이 변조됐는지 검사할 수 있습니다

#### 생산자 영역

생산자가 헬름 명령으로 작업 공간을 생성하면

templates 디렉터리로 애플리케이션 배포에 필요한 여러 야믈 파일과 구성 파일을 작성할 수 있습니다

이때 templates 디렉터리에서 조건별 분기, 값 전달 등을 처리할 수 있도록 values.yaml에 설정된 키를 사용합니다

필요한 패키지의 여러 분기 처리나 배포에 대한 구성이 완료되면 생산자는 차트의 이름, 목적, 배포되는 애플리케이션 버전과 같은 패키지 정보를 Charts.yaml 에 채워 넣습니다

#### 아티팩트허브 영역

아티팩트허브 검색을 통해 사용자가 찾고자 하는 애플리케이션 패키지를 검색하면 해당 패키지가 저장된 주소를 확인합니다

각 애플리에키션을 개발하는 주체가 관리합니다

#### 사용자 영역

사용자는 설치하려는 애플리케이션의 차트 저장소 주소를 아티팩트허브에서 얻으면 헬름을 통해서 주소를 등록합니다

이를 최신으로 업데이트한 이후에 차트를 내려받고 설치합니다

## 5.3 : 젠킨스 설치 및 설정하기

### 5.3.1 : 헬름으로 젠킨스 설치하기

#### 테인트(taints)와 톨러레이션(tolerations)

일반적으로 테인트와 톨러레이션은 혼합해서 사용하는데, 개념적으로 매우 혼동이 올 수 있습니다

**테인트**는 손에 잡기 싫은 것, 피하고 싶은 것, 가지 말았으면 하는 것

테인트가 설정되면 그곳은 설거지가 끝난 이후에 수채구멍과 같습니다

하지만, 상황에 따라 테인트가 설정돼 있는 곳을 꼭 만져야 할 때가 있는데, 이런 경우는 인내하고 처리해야 합니다

그러기 위해서는 **톨러레이션**. 즉, 참아내는 인내가 필요한 것입니다

쿠버네티스의 테인트와 톨러레이션은 사전적인 의미와 반대입니다

매우 특별하게 취급돼야 하는 곳에는 테인트를 설정해, 쉽게 접근하지 못하는 소중한 것으로 설정합니다

그리고, 톨러레이션이라는 특별한 키를 가져야만 이곳에 출입할 수 있습니다

```yaml
taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master

tolerations:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
```

테인트는 키와 값 그리고 키와 값에 따른 효과의 조합을 통해 테인트를 설정한 노드에 파드 배치의 기준을 설정합니다

톨러레이션은 테인트와 마찬가지로 키, 값, 효과를 가지고 있으며 이외에 연산자를 추가로 가지고 있습니다

|효과|테인트가 설정된 노드에 파드 신규 배치|파드가 배치된 노드에 테인트 설정|
|---|---|---|
|NoSchedule|노드에 파드 배치를 거부|노드에 존재하는 파드 유지|
|PreferNoSchedule|다른 노드에 파드 배치가 불가능할 때는 노드에 파드 배치|노드에 존재하는 파드 유지|
|NoExecute|노드에 파드 배치를 거부|파드를 노드에서 제거|

톨러레이션은 테인트가 설정된 노드로 들어가기 위한 특별한 열쇠의 역할을 하며 키와 효과는 반드시 일치해야 합니다

operator 에는 Equal과 Exists가 있습니다

Equal : taint와 toleration의 키와 값 그리고 효과까지 일치하는 경우 Exists : 키와 효과의 일치 여부를 판단하고, 값은 반드시 생략해야 합니다

(키와 효과를 모두 생략한 상태에서 Exists 연산자만 사용한다면 테인트의 키와 효과는 모든 키와 모든 효과를 의미하므로 Exists 연산자 하나만으로도 테인트가 설정된 모든 노드에 대해 해당 톨러레이션을 설정한
파드를 배포할 수 있게 됩니다)

### 5.3.2 젠킨스 살펴보기

젠킨스 컨트롤러가 단독으로 설치할 경우에는 컨트롤러가 설치된 서버에서

젠킨스 자체 시스템 관리, CI/CD 설정, 빌드 등의 작업을 모두 젠킨스 컨트롤러 단일 녿에서 수행합니다

컨트롤러-에이전트 구조로 설치할 경우 컨트롤러는 젠킨스 자체의 관리 및 CI/CD와 관련된 설정만을 담당하고 실제 빌드 작업은 에이전트로 설정된 노드에서 이루어집니다

### 5.3.4 : 젠킨스 에이전트 설정하기

쿠버네티스의 역할 부여 구조는 **할 수 있는 일**(무엇을 할 수 있나?)과 **할 수 있는 주체**(누가 할 수 있나?)의 결합으로 이루어집니다

- Rules

역할 기반 접근 제어에서 '할 수 있는 일'과 관련된 Role, ClusterRole이 가지고 있는 자세한 행동 규칙입니다

특정 API를 통해서 어떠한 자원에 접근해 목록이나 정보를 조회하거나 자원을 생성, 삭제, 수정하는 등의 행위를 하는 것을 의미합니다

- Role, ClusterRole

'할 수 있는 일'을 대표하는 오브젝트입니다

Rules에 적용된 규칙에 따른 동작을 할 수 있으며 적용 범위에 따라 Role과 ClusterRole로 나뉩니다

Role은 해당 Role을 가진 주체가 특정 namespace 에 대해서 접근할 수 있습니다

ClusterRole은 해당 ClusterRole을 가진 주체가 쿠버네티스 클러스터 전체에 대해서 접근할 수 있도록 합니다

- RoleBinding, ClusterRoleBinding

'무엇을 할 수 있나?' 라는 속성을 '할 수 있는 주체' 속성의 Subjects와 연결시켜주는 역할을 합니다

RoleBinding은 앞에서 설명한 Role과 결합하여 네임스페이스 범위의 접근 제어를 수행합니다

ClusterRoleBinding은 ClusterRole과 결합해 클러스터 전체 범위의 접근 제어를 수행합니다

- Subjects

행위를 수행하는 주체를 의미합니다

Subjects는 특정 사용자 혹은 그룹, 서비스 어카운트를 속성으로 가질 수 있습니다

쿠버네티스 클러스터에 등록된 사용자의 목록은 kubeconfig의 users 섹션에 기록돼 있습니다

파드는 네임스페이스에 존재하는 default 서비스 어카운트를 사용하거나 특정한 서비스 어카운트를 사용하도록 설정할 수 있으며

파드 내부의 프로세스는 설정된 서비스 어카운트로서 쿠버네티스상에 존재하는 자원에 접근을 시도할 수 있습니다