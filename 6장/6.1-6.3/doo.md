# 모니터링

거의 모든 모니터링 도구는 `수집 → 통합 → 시각화` 구조로 돼 있습니다.

컨테이너 인프라 환경에서는 데이터를 프로메테우스로 수집하고, 수집한 정보를 한 곳에 모아 그라파나로 시각화한다.

### 모니터링 도구 선택하기

프로메테우스와 그라파나는 오픈소스 도구인데, 오픈 소스는 가능한 한 단일 도구에서 단일 기능만을 구현하는 것을 선호한다. 

모든 기능을 모아둔 하나의 도구를 사용하지 않고 프로메테우스+그라파나와 같은 혼합 구조를 사용하는 이유는

- 비용 : 모니터링 대상마다 라이선스 관련한 비용이 발생하고, 클라우드 같은 과금제 서비스를 이용하면 네트워크와 저장 공간에 따른 추가 비용이 발생한다. ex) 데이터독, 뉴렐릭은 모니터링 대상마다 비용 부과
- 보안 : 서비스형 모니터링 도구들은 대부분 외부에 데이터를 저장해 모니터링하는데, 보안에 민감하여 내부에서 모든 데이터를 처리하는 경우엔 서비스형 모니터링 도구를 사용하기 어렵다.

## 쿠버네티스 환경에서 모니터링

쿠버네티스는 노드는 kubelet을 통해 파드를 관리하며, 파드의 CPU나 메모리같은 메트릭 정보를 수집하기 위해 kubelet에 내장된 cAdvisor를 사용한다. 

cAdvisor는 구글이 만든 커네팅너 매트릭 수집 도구로, 쿠버네티스 클러스터 위에 배포된 여러 컨테이너가 사용하는 메트릭 정보를 수집한 후 이를 가공해서 kubelet에 전달하는 역할을 한다.

- cAdvisor로 수집하고, kubelet으로 공개되는 데이터가 있어도 외부에서 이를 모아서 표현해주는 도구가 없다면 의미가 없다.

### 리소스 메트릭 파이프라인

메트릭 서버에서 수집한 데이터로 여러 기능을 수행하도록 구성한 것

- 문제점 : 메트릭 서버는 집계한 데이터를 메모리에만 저장하므로 데이터를 영구적으로 보존하기 어렵고, 현재 시점의 데이터만 출력된다.

### 완전한 모니터링 파이프라인

메트릭 데이터를 저장 공간에 따로 저장하는 방식

- 위의 일시적인 집계 데이터 문제를 해결한다.
- 완전한 모니터링 파이프라인으로 구성한 프로메테우스는 여러 수집 대상이 공개하는 메트릭 데이터를 모아 시계열 데이터베이스에 저장한다.
- 누적된 메트릭 데이터로는 쿠버네티스 인프라의 상태 변화를 파악할 수 있고, 적절한 위험 감지 및 조치를 취할 수 있다.

# 프로메테우스

### 프로메테우스 서버 (prometheus server)

프로메테우스의 주요 기능을 수행하는 요소

[ 프로메테우스 서버의 3가지 역할 ]

1. 수집기 : 노드 익스포터 외 여러 대상에서 공개된 메트릭을 수집한다.
→ ‘서비스 디스커버리’라는 방법을 통해 수집 대상을 찾는다.
2. 시계열 데이터베이스 : 수집한 시계열 메트릭 데이터를 저장한다.
3. 웹 UI : 저장된 데이터를 질의하거나 수집 대상의 상태를 확인한다.

### 노드 익스포터 (node-exporter)

노드의 시스템 메트릭 정보를 HTTP로 공개하는 역할

- 설치된 노드에서 특정 파일들을 읽고, 이를 프로메테우스 서버가 수집할 수 있는 메트릭 데이터로 변환한 후에 노드 익스포터에서 HTTP 서버로 공개한다.
- 공개된 내용을 프로메테우스 서버에서 수집해간다.

### 쿠버 스테이트 메트릭 (kube-state-metric)

API서버로 쿠버네티스 클러스터의 여러 메트릭 데이터를 수집한 후, 이를 프로메테우스 서버가 수집할 수 있는 메트릭 데이터로 변환해 공개하는 역할

- 쿠버 스테이트 메트릭 덕분에 프로메테우스가 쿠버네티스 클러스터의 여러 정보를 쉽게 획득할 수 있다.

### 얼럿 매니저 (alert manager)

프로메테우스에 경보 규칙을 설정하고, 경보 이벤트가 발생하면 설정된 경보 메시지를 대상에게 전달한다.

### 푸시게이트웨이 (pushgateway)

배치와 스케줄 작업 시 수행되는 일회성 작업들의 상태를 저장하고 모아서 프로메테우스가 주기적으로 가져갈 수 있도록 공개한다.

# 서비스 디스커버리

프로메테우스는 수집 대상을 자동으로 인식하고 필요한 정보를 수집한다.

정보를 수집하려면 일반적으로 에이전트를 설정해야 하지만, 쿠버네티스는 사용자가 에이전트에 추가로 입력할 필요 없이 자동으로 메트릭을 설정할 수 있다. 

### 서비스 디스커버리 동작 순서

1. 프로메테우스 서버는 컨피그맵에 기록된 내용을 바탕으로 대상을 읽어온다.
2. 읽어온 대상에 대한 메트릭을 가져오기 위해 API 서버에 정보를 요청한다.
3. 요청을 통해 알아온 경로로 메트릭 데이터를 수집한다.

→ 프로메테우스 서버와 API 서버가 주기적으로 데이터를 주고받아 수집 대상을 업데이트하고, 수집 대상에서 공개되는 메트릭을 자동으로 수집한다.

## 서비스 디스커버리를 위한 2가지 경로

서비스 디스커버리 방법은 대상에 따라 크게 2가지 경로로 나뉜다.

1. cAdvisor : 쿠버네티스 API에 직접 연결돼 메트릭을 수집하는 cAdvisor 방법
2. 익스포터(에이전트) : API 서버가 경로를 알려주어 메트릭을 수집할 수 있는 익스포터(에이전트) 방법

### cAdvisor

cAdvisor의 메트릭이 API 서버를 통해 노출되면 프로메테우스 서버가 쉽게 수집하도록 변환하는 과정을 거친다.

- 새롭게 배포되는 디플로이먼트가 있으면 이를 configmap에 수집 대상으로 지정하여 자동으로 메트릭이 수집된다.
- cAdvisor는 각 노드에 컨테이너 시스템 정보를 담고 있는 특정 파일들을 읽어들여 메트릭을 수집하고, 프로메테우스가 수집할 수 있도록 컨테이너 메트릭을 프로메테우스의 메트릭으로 변환해 공개한다.

### 익스포터

서비스 디스커버리에서 수집은 자동으로 이뤄지지만, 익스포터는 2가지 사전 작업을 해야한다.

[ 익스포터 2가지 사전 작업 ]

1. API 서버에서 등록돼 경로를 알 수 있게 해야 한다.
2. 익스포터가 데이터를 프로메테우스 타입으로 노출해야 한다.

[ 어노테이션 설정 ]

어노테이션 : 소스 코드에 주석으로 추가되는 메타데이터로, 여러 어플리케이션이나 다른 도구에 정보를 전달하는 역할을 한다. 

- 프로메테우스 서버가 배포된 어플리케이션을 API 서버에서 찾아 메트릭을 수집하려면 어노테이션 설정이 가장 중요하다.
- 어노테이션을 이용해 수집 대상을 판별하고 경로를 재조합한다.

```
# nginx deployment 배포
kubectl apply -f ~/_Book_k8sInfra/.../nginx-status-annot.yaml
```

nginx 디플로이먼트를 배포해도, 메트릭은 수집되지 않는다.
→ 이는 메트릭이 공개되지 않았기 때문이다.

[ 프로메테우스에서 메트릭을 공개하는 2가지 방법 ]

1. 프로그래밍 언어의 프로메테우스 SDK를 사용해 직접 메트릭을 공개하도록 작성하는 방법
2. 미리 만들어 둔 익스포터를 사용해 메트릭을 공개하는 방법

```
# 익스포터 배포 -> 컨테이너로부터 메트릭을 받아 공개할 수 있게 됨
kubectl apply -f ~/_Book_k8sInfra/.../nginx-status-metrics.yaml
```

여기서는 미리 만들어 둔 익스포터를 사용하여 메트릭을 공개한다.

배포한 nginx에서 제공하는 nginx-prometheus-exporter 익스포터를 사이드카 패턴으로 배포하여 컨테이너로부터 받은 메트릭을 공개할 수 있도록 한다.

[ 멀티 컨테이너 패턴 ]

- 사이드카 : 메인 컨테이너의 기능을 확장하거나 기능을 향상하고자 할 때 추가하는 패턴
- 앰배서더 : 사용자가 외부에서 접근할 때 앰배서더 컨테이너를 통해 통신이 이루어지는 형태.
→ 세부적인 외부 접근 대상이나 방법은 앰배서더 컨테이너에 위임한다. 
→ 주로 프록시 컨테이너를 구성해 외부의 접근을 제어하고 내부 자원을 보호하는 구성이다.
- 어댑터 : 메인 컨테이너의 정보를 외부에서 사용할 수 있는 형식으로 변환하는 컨테이너가 추가된 형태

[ 다양한 종류의 프로메테우스 익스포터 ]

프로메테우스는 대상을 모니터링하기 위해 다양한 형태의 익스포터를 사용한다.

| 분야 | 데이터베이스 | 메시징 시스템 | 스토리지 | 외부 모니터링 시스템 |
| --- | --- | --- | --- | --- |
| 주요 관심사 | 안정성 지표, 내부 구조 | 처리량, 전달 성공률 | 사용량 | 외부 시스템 통합 |
| 대표적 수집 대상 | ElasticSearch, MongoDB, MySQL, Oracle | Kafka, RabbitMQ, NATS | Ceph, Gluster, GPFS | AWS CloudWatch, Google Stackdriver, Azure Monitor |

## 노드 익스포터로 쿠버네티스 노드 메트릭 수집하기

노드 익스포터는 쿠버네티스 노드의 상태 값을 메트릭으로 추출하는 데 특화되어 있다. 

- 노드 익스포터는 각 노드(마스터, 워커)에 있는 `/proc` 과 `/sys` 에 있는 값을 메트릭으로 노출하도록 구현돼 있다. (각 노드의 /proc, /sys 디렉토리를 마운트해서 사용한다.)
- `/proc` : 리눅스 운영 체제에서 구동 중인 프로세스들의 정보를 파일 시스템 형태로 연결한 디렉토리. 디렉토리 안에는 현재 구동중인 프로세스들의 프로세스 id가 디렉토리 형태로 나타나며, 각 디렉토리 내부에 해당 프로세스에 대한 상태나 실행 환경에 대한 정보가 들어있다.
→ 모니터링 도구는 구동중인 프로세스의 **정보나 상태, 자원 사용량** 등을 알 수 있다.
- `/sys` :  저장 장치, 네트워크 장치, 입출력 장치 같은 각종 장치를 운영 체제에서 사용할 수 있도록 파일 시스템 형태로 연결한 디렉토리. 이 디렉토리 내부에 있는 파일들을 분석하면 전체 장치의 상태를 알 수 있다.
→ 모니터링 도구는 **시스템 장치의 상태 정보**를 알 수 있다.

→ 노드 익스포터는 각 쿠버네티스 노드의 `/proc` , `/sys` 에 있는 파일들을 읽어서 프로메테우스가 받아들일 수 있는 메트릭 형태로 변환하고, 이를 HTTP를 통해 `/metrics` 주소로 공개한다.

노드의 CPU 상태별로 사용된 시간을 합한 데이터나 노드별로 사용 가능한 메모리의 용량 등을 알 수 있다.

## 쿠버 스테이트 메트릭으로 쿠버네티스 클러스터 메트릭 수집하기

쿠버 스테이트 메트릭 : 쿠버네티스 상태를 보여주는 메트릭이다.

- 쿠버네티스 상태에 관한 정보를 가져와서 프로메테우스가 받아들일 수 있는 메트릭 형태로 변환하고, 이 메트릭을 HTTP 서버를 통해 `/metrics` 주소로 공개한다.
→ 노드 익스포터와의 공통점
- 각 노드의 특정 디렉토리를 마운트해서 사용하지 않고, 이미 API 서버에 모인 값들을 수집한다.
→ 노드 익스포토와의 차이점

쿠버네티스에 배포된 파드가 다시 시작하는 경우 이를 누적해 기록한 데이터나 쿠버네티스에 존재하는 서비스들이 생성된 시간 등을 알 수 있다. → API 서버를 통한 명령 데이터인듯하다.

# PromQL로 메트릭 데이터 추출

수집된 메트릭 데이터를 그대로 사용하지 않고 필요한 데이터 가공해서 추출하는 경우, PromQL을 통해 필요한 메트릭 데이터를 정확하게 추출할 수 있다.

## 메트릭 데이터의 구조

### 메트릭 값의 종류

- 카운터(Counter) : 누적된 값을 표현하는 데 사용하는 메트릭 타입이다.
    - 카운터에 누적된 값으로 구견별로 변화율을 파악해 해당 값이 어느 정도 추세로 증가하는지 알 수 있다.
    → 이벤트나 오류 등이 급증하는 구간을 파악하는 데 적합하다.
    → 값이 누적되기 때문에 특정 순간의 데이터를 표현하는 데는 적합하지 않다.
    - 값을 중점적으로 보기보다 값이 얼마만큼 변했는지 변화율을 주로 확인한다.
- 게이지(Gauge) : 특정 시점의 값을 표현하는 데 사용하는 메트릭 타입이다.
    - 시점별로 증가나 감소를 모두 표현할 수 있다.
    - CPU 온도나 메모리 사용량 등은 누적된 값이 필요하지 않고 조회하는 순간의 값이 중요하므로 게이지 타입이 적합하다.
- 히스토그램 : 사전에 미리 정의된 구간 안에 있는 메트릭 값의 빈도를 측정한다.
    - 버킷 : 익스포터를 구현하는 단계에서 정의한 구간
    - 히스토그램을 사용해 클라이언트가 서버로 HTTP 요청을 한 경우에 응답 시간과 맞는 버킷에 값을 추가하고 이벤트 횟수를 저장해 표시할 수 있다.
- 서머리 : 히스토그램과 비슷하게 구간 내에 있는 메트릭 값의 빈도를 측정한다.
    - 클라이언트 요청에 따른 응답 시간을 관찰하고 저장할 때 사용할 수 있다.
    - 하지만, 히스토그램과 달리 구간이 지정되는 것이 아니라 프로메테우스 자체적으로 0~1 사이로 구간을 미리 정해놓는다.

→ 일반적으로 메트릭 이름의 끝 단어를 통해 메트릭 타입을 추정할 수 있다. 

eX) total로 끝나면 누적이므로 카운터 타입, bytes 또는 created로 끝나면 해당 시점의 용량 또는 생성됨이므로 게이지 타입 등 

### 메트릭 레이블

모든 메트릭 데이터는 하나 이상의 레이블을 가진다. 프로메테우스의 레이블은 일반적인 주석이 아니라 메트릭 데이터의 다양한 내용을 표현하는 유일한 방법이다.

- 제공하고 싶은 다수의 내용을 key-value 형태로 넣는다.
→ 이를 통해 원하는 레이블을 검색하고 선택적으로 추출할 수 있다. ex) `up{job=”prometheus”}`

### 메트릭 레이블 매처

레이블 매처 : 메트릭 레이블에 조건을 줘서 검색하는 방법

[ 4가지 조건 기호 ] 

- `=` : 조건에 넣은 값과 레이블 값이 같은 메트릭을 보여준다. 
ex) `{instacne=”m-k8s”}` → instance 레이블 값이 m-k8s인 메트릭을 찾아서 출력
- `!=` : 조건에 넣은 값과 레이블 값이 다른 메트릭을 보여준다. 
ex) `{instacne!=”m-k8s”}` → instance 레이블 값이 m-k8s가 아닌 메트릭을 찾아서 출력
- `=~` : 조건에 넣은 정규표현식에 해당하는 메트릭을 보여준다. 
ex) `{instacne=~”w.+”}` → instance 레이블 값이 w로 시작하는 메트릭을 찾아서 출력
- `!~` : 조건에 넣은 정규표현식에 해당하지 않는 메트릭을 보여준다. 
ex) `{instacne!~”w.+”}` → instance 레이블 값이 w로 시작하지 않는 모든 메트릭을 찾아서 출력

## PromQL 연산자

PromQL 연산자는 메트릭의 값을 이용한 여러 가지 활용 방법을 제공한다.

### 비교 연산자

메트릭 값을 비교해 조건에 해당하는 값을 가진 대상을 검색한다. 

- 주로 수집 대상의 상태를 파악하는 데 사용한다.
- 레이블 매처와 유사한 형태이나 비교 대상이 숫자이므로 크기를 구분하는 조건들이 있다.
- ==, !=, >, <, >=, <=  연산자가 사용된다.

ex) `kube_pod_container_status_restart_total > 0` 

### 논리 연산자

연산자 앞뒤로 입력되는 PromQL 표현식 레이블의 키와 값을 기준으로 조건 연산을 수행해 값을 반환한다.

- and : 양쪽 표현식의 레이블 값이 서로 일치하는 경우 왼쪽 값을 반환한다.
- or : 왼쪽 표현식으로 출력되는 값이 없는 경우 오른쪽 값을 반환한다.
- unless : 양쪽 표현식을 비교해서 오른쪽 표현식의 출력 값에서 왼쪽 표현식에 나온 값들을 모두 제외하고 반환한다.

논리 연산자는 검색 대상이 잘못됐을 때 이를 수정하거나 검출할 때 사용한다.

### 산술 연산자

검색된 메트릭의 값을 사용자가 원하는 형태로 바꿔준다. 

- 주로 수치 단위를 변경하는 데 사용된다.

ex) `node_memory_MemAvailable_bytes /1024/1024/1024`
→ 노드에서 사용가능한 메모리 크기를 반환받아 /1024를 3번 사용해 Byte 단위를 Gib로 변경했다.
→ /1024를 한번 사용할 때마다 Byte 단위가 각각 Kib, Mib, Gib로 변경된다.

[Mib와 MB는 서로 다른 단위](https://brunch.co.kr/@leedongins/133)

### 집계 연산자

검색된 메트릭 값을 종합해 유용한 형태로 변환한다.

- 수집된 값에서 총합, 평균, 계측된 수 등을 바로 파악할 때 사용된다.
- 다른 연산자에 존재하지 않는 분류와 관련된 by(그룹화), without(제외) 등의 추가 옵션을 제공한다.

ex) `avg(node_cpu_seconds_total{mode=”idle”} by (kubernetes_node)` 는 노드별로 CPU를 사용하지 않는 시간의 평균을 구한다.

## PromQL 데이터 타입

프로메테우스는 시꼐열 데이터베이스로, 메트릭 데이터에도 시간 정보가 있다.

시간을 포함한 메트릭 데이터를 확인하려면 쿼리를 입력할 때 `[구간 값]` 을 입력해야 한다.
ex) `node_cpu_seconds_total[5m]` → 5분 동안 발생된 메트릭 값을 요청한다.

메트릭 데이터를 받아오는 구간을 프로메테우스에서는 `레인지 셀렉터`라고 한다.
→ 레인지 셀렉터를 설정하면 메트릭 값과 함께 시간 정보가 나타나 각 메트릭 값을 구분할 수 있다.
→ 레인지 셀렉터의 단위는 ms(밀리초), s(초), m(분), h(시간), d(일), w(주), y(년)를 사용할 수 있다.

- 레인지 벡터 : 구간이 있는 PromQL 데이터 타입
→ `node_cpu_seconds_total[5m]` : 프로메테우스 수집 주기(default 1분)마다 `@유닉스 시간` 데이터가 `누적으로` 남는다.

```
명령어 : node_cpu_seconds_total{...레이블 조건}[5m]
------------------------------------------------------
[1분 경과 후 명령어 실행]
32.84
@1610711144.307
------------------------------------------------------
[2분 경과 후 명령어 실행]  // 1분에 쌓였던 데이터에 누적으로 2분에 집계된 데이터가 쌓인다.
32.84
@1610711144.307
76.27
@1610711204.307
------------------------------------------------------
[3분 경과 후 명령어 실행]  // 1분 + 2분에 쌓였던 데이터 위에 3분에 집계된 데이터가 쌓인다.
32.84
@1610711144.307
76.27
@1610711204.307
122
@1610711264.308

... 시간이 지나면서 5분까지의 데이터가 누적으로 쌓여 보여진다.
```

- 인스턴트 벡터 : 특정(일반적으로 현재 시점) 시점에 대한 메트릭 값만을 가지는 PromQL 데이터 타입
→ `node_cpu_seconds_total` : 현재 시점에 누적된 초만 보여준다.

```
명령어 : node_cpu_seconds_total{...레이블 조건}
------------------------------------------------------
[1분 경과 후 명령어 실행]
32.84
------------------------------------------------------
[2분 경과 후 명령어 실행]
76.27
------------------------------------------------------
[3분 경과 후 명령어 실행]
122

// 타임스탬프 데이터 없이, 현재 시점까지 사용된 시간 총합만 보여준다.
```

- 레인지 벡터, 인스턴트 벡터 외에도 실수 값을 표현하는 스칼라 타입과 문자열을 표현하는 스트링 타입이 있다.

## PromQL 함수

프로메테우스는 인스턴트 벡터로 추출한 메트릭을 그대로 사용하는 경우도 많지만, 함수를 사용하여 다른 데이터를 얻기도 한다.

[ 프로메테우스의 대표적인 함수 ]

| 종류 | 용도 | 함수 |
| --- | --- | --- |
| 연산 함수 | 수학 연산에 사용 | abs(절댓값), ceil(올림), floor(내림), round(반올림), predict_linear(예측값) 등 |
| 변환 함수 | 데이터 타입 간 변환에 사용 | rate(변화율), irate(순간 변화율), scalar(스칼라로 변환), vector(벡터로 변환) 등 |
| 집계 함수 | 수집된 레인지 벡터의 데이터 집계를 위해 사용 | avg_over_time(평균), sum_over_time(합계), count_over_time(계수) 등 |

[ 많이 쓰는 함수들 ]

- rate : 수집된 값들의 변화율을 구할 때 사용한다.
→ 주로 값이 증가하는 카운터 형식의 메트릭에 사용되며, 지정된 구간이 얼마나 빠르게 변화했는지 알기 위한 지표로 사용된다.
- irate : rate와 변화율을 구하는 부분은 같다.
→ 하지만 rate는 구간 시작 값과 구간 종료 값의 차이에 대한 변화율을 다루고, irate는 구간 종료 바로 전 값과 구간 종료 값의 차이에 대한 변화율을 나타내는 점이 다르다. 
→ 따라서 구간이 매우 길면 irate 변화율은 큰 의미가 없기 때문에 그냥 rate를 사용하는 것이 낫다.
- predict_linear : 레인지 벡터로 수집된 과거 메트릭 데이터를 기반으로 앞으로 생성될 메트릭 값을 예측한다.

## 서머리와 히스토그램

### 서머리

서머리는 이미 공개된 메트릭 값을 조회하면 바로 확인할 수 있다.

- 익스포터에서 이미 만들어진 값을 보여준다.
- 히스토그램과 달리 구간이 지정되는 것이 아니라 프로메테우스 자체적으로 0~1 사이로 구간을 미리 정해놓는다.

ex) `prometheus_target_interval_length_seconds`

### 히스토그램

쿼리 입력기에서 쿼리를 보내면 그때서야 내부 계산식을 통해 히스토그램 메트릭을 생성한다.

- 사전에 미리 정의된 구간 안에 있는 메트릭 값의 빈도를 측정한다.
- 히스토그램에 연산자를 추가하여 더욱 유용한 정보를 얻을 수도 있다.

ex) `histogram_quantile(0.99, rate(apiserver_request_duration_seconds_bucket[5m]))`